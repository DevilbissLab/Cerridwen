<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.20) on Tue Aug 22 13:03:51 AEST 2023 -->
<title>TransferEntropyCalculatorDiscrete</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-08-22">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../jquery/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="TransferEntropyCalculatorDiscrete";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":41,"i42":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">infodynamics.measures.discrete</a></div>
<h2 title="Class TransferEntropyCalculatorDiscrete" class="title">Class TransferEntropyCalculatorDiscrete</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="InfoMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">infodynamics.measures.discrete.InfoMeasureCalculatorDiscrete</a></li>
<li>
<ul class="inheritance">
<li><a href="ContextOfPastMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">infodynamics.measures.discrete.ContextOfPastMeasureCalculatorDiscrete</a></li>
<li>
<ul class="inheritance">
<li>infodynamics.measures.discrete.TransferEntropyCalculatorDiscrete</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="ChannelCalculatorDiscrete.html" title="interface in infodynamics.measures.discrete">ChannelCalculatorDiscrete</a></code>, <code><a href="../../utils/AnalyticNullDistributionComputer.html" title="interface in infodynamics.utils">AnalyticNullDistributionComputer</a></code>, <code><a href="../../utils/EmpiricalNullDistributionComputer.html" title="interface in infodynamics.utils">EmpiricalNullDistributionComputer</a></code></dd>
</dl>
<hr>
<pre>public class <span class="typeNameLabel">TransferEntropyCalculatorDiscrete</span>
extends <a href="ContextOfPastMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">ContextOfPastMeasureCalculatorDiscrete</a>
implements <a href="ChannelCalculatorDiscrete.html" title="interface in infodynamics.measures.discrete">ChannelCalculatorDiscrete</a>, <a href="../../utils/AnalyticNullDistributionComputer.html" title="interface in infodynamics.utils">AnalyticNullDistributionComputer</a></pre>
<div class="block"><p>Implements <b>transfer entropy</b>
 for univariate discrete time-series data.
 That is, it is applied to <code>int[]</code> data, indexed
 by time.
 See Schreiber below for the definition of transfer entropy,
 and Lizier et al. for the definition of local transfer entropy.
 Specifically, this class implements the pairwise or <i>apparent</i>
 transfer entropy; i.e. we compute the transfer that appears to
 come from a single source variable, without examining any other
 potential sources
 (see Lizier et al, PRE, 2008).</p>
  
 <p>
 Usage of the child classes implementing this interface is intended to follow this paradigm:
 </p>
 <ol>
                <li>Construct the calculator via <a href="#%3Cinit%3E(int,int)"><code>TransferEntropyCalculatorDiscrete(int, int)</code></a>
                        or <a href="#%3Cinit%3E(int,int,int)"><code>TransferEntropyCalculatorDiscrete(int, int, int)</code></a>
                        or <a href="#%3Cinit%3E(int,int,int,int,int,int)"><code>TransferEntropyCalculatorDiscrete(int, int, int, int, int, int)</code></a>;</li>
                <li>Initialise the calculator using
                        <a href="#initialise()"><code>initialise()</code></a>;</li>
                <li>Provide the observations/samples for the calculator
        to set up the PDFs, using one or more calls to
                        the set of <a href="#addObservations(int%5B%5D,int%5B%5D)"><code>addObservations(int[], int[])</code></a> methods, then</li>
                <li>Compute the required quantities, being one or more of:
                        <ul>
                                <li>the average TE: <a href="#computeAverageLocalOfObservations()"><code>computeAverageLocalOfObservations()</code></a>;</li>
                                <li>the local TE values for these samples: <code>#computeLocalOfPreviousObservations()</code></li>
                                <li>local TE values for a specific set of samples: e.g.
                                <a href="#computeLocalFromPreviousObservations(int%5B%5D,int%5B%5D)"><code>computeLocalFromPreviousObservations(int[], int[])</code></a> etc.</li>
                                <li>the distribution of TE values under the null hypothesis
                                        of no relationship between source and
                                        destination values: <a href="#computeSignificance(int)"><code>computeSignificance(int)</code></a> or
                                        <a href="#computeSignificance(int%5B%5D%5B%5D)"><code>computeSignificance(int[][])</code></a>.</li>
                        </ul>
                </li>
                <li>As an alternative to steps 3 and 4, the user may undertake
                        standalone computation from a single set of observations, via
                e.g.: <a href="#computeLocal(int%5B%5D,int%5B%5D)"><code>computeLocal(int[], int[])</code></a> or
                <a href="#computeAverageLocal(int%5B%5D%5B%5D,int)"><code>computeAverageLocal(int[][], int)</code></a>.</li>
                <li>
                Return to step 2 to re-use the calculator on a new data set.
                </li>
        </ol>
 
 <p><b>References:</b><br/>
 <ul>
        <li>T. Schreiber, <a href="http://dx.doi.org/10.1103/PhysRevLett.85.461">
 "Measuring information transfer"</a>,
  Physical Review Letters 85 (2) pp.461-464, 2000.</li>
  <li>J. T. Lizier, M. Prokopenko and A. Zomaya,
  <a href="http://dx.doi.org/10.1103/PhysRevE.77.026110">
  "Local information transfer as a spatiotemporal filter for complex systems"</a>
  Physical Review E 77, 026110, 2008.</li>
 </ul></div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Joseph Lizier, <a href="joseph.lizier at gmail.com">email</a>,
 <a href="http://lizier.me/joseph/">www</a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#base_power_l">base_power_l</a></span></code></th>
<td class="colLast">
<div class="block">A cached value of base^sourceHistoryEmbedLength</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#delay">delay</a></span></code></th>
<td class="colLast">
<div class="block">Source-destination delay to consider the information transfer across</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#destEmbeddingDelay">destEmbeddingDelay</a></span></code></th>
<td class="colLast">
<div class="block">Embedding delay for the destination variable,
  i.e.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#estimateComputed">estimateComputed</a></span></code></th>
<td class="colLast">
<div class="block">Tracks whether the measure has been computed since the last initialisation</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#maxShiftedSourceValue">maxShiftedSourceValue</a></span></code></th>
<td class="colLast">
<div class="block">A cached value of each discrete value left shifted (in "base" counting) by (sourceHistoryEmbedLength-1).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#periodicBoundaryConditions">periodicBoundaryConditions</a></span></code></th>
<td class="colLast">
<div class="block">Whether to assume periodic boundary conditions for channels across
  the boundary of the multidimensional
  calls supplying observations, e.g.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sourceEmbeddingDelay">sourceEmbeddingDelay</a></span></code></th>
<td class="colLast">
<div class="block">Embedding delay for the source variable,
  i.e.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sourceHistoryEmbedLength">sourceHistoryEmbedLength</a></span></code></th>
<td class="colLast">
<div class="block">Embedding length of the source variable.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int[][][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sourceNextPastCount">sourceNextPastCount</a></span></code></th>
<td class="colLast">
<div class="block">Counts of (source,dest_next,dest_embedded_past) tuples</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sourcePastCount">sourcePastCount</a></span></code></th>
<td class="colLast">
<div class="block">Counts of (source,dest_embedded_past) tuples</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#startObservationTime">startObservationTime</a></span></code></th>
<td class="colLast">
<div class="block">First time step at which we can take an observation
  (needs to account for an embedding in the previous steps)</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="fields.inherited.from.class.infodynamics.measures.discrete.ContextOfPastMeasureCalculatorDiscrete">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;infodynamics.measures.discrete.<a href="ContextOfPastMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">ContextOfPastMeasureCalculatorDiscrete</a></h3>
<code><a href="ContextOfPastMeasureCalculatorDiscrete.html#base_power_k">base_power_k</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#k">k</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#maxShiftedValue">maxShiftedValue</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#nextCount">nextCount</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#nextPastCount">nextPastCount</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#noObservationStorage">noObservationStorage</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#pastCount">pastCount</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="fields.inherited.from.class.infodynamics.measures.discrete.InfoMeasureCalculatorDiscrete">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;infodynamics.measures.discrete.<a href="InfoMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">InfoMeasureCalculatorDiscrete</a></h3>
<code><a href="InfoMeasureCalculatorDiscrete.html#average">average</a>, <a href="InfoMeasureCalculatorDiscrete.html#base">base</a>, <a href="InfoMeasureCalculatorDiscrete.html#debug">debug</a>, <a href="InfoMeasureCalculatorDiscrete.html#log_2">log_2</a>, <a href="InfoMeasureCalculatorDiscrete.html#log_2_base">log_2_base</a>, <a href="InfoMeasureCalculatorDiscrete.html#log_base">log_base</a>, <a href="InfoMeasureCalculatorDiscrete.html#max">max</a>, <a href="InfoMeasureCalculatorDiscrete.html#min">min</a>, <a href="InfoMeasureCalculatorDiscrete.html#observations">observations</a>, <a href="InfoMeasureCalculatorDiscrete.html#power_of_2_base">power_of_2_base</a>, <a href="InfoMeasureCalculatorDiscrete.html#std">std</a></code></li>
</ul>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">TransferEntropyCalculatorDiscrete</a></span>()</code></th>
<td class="colLast">
<div class="block">Create a new TE calculator with all parameters as default
 (base 2 and all embedding/delay parameters 1)</div>
</td>
</tr>
<tr class="rowColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(int,int)">TransferEntropyCalculatorDiscrete</a></span>&#8203;(int&nbsp;base,
                                 int&nbsp;destHistoryEmbedLength)</code></th>
<td class="colLast">
<div class="block">Create a new TE calculator for the given base and destination history embedding length
  (leave the other embedding parameters as default)</div>
</td>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(int,int,int)">TransferEntropyCalculatorDiscrete</a></span>&#8203;(int&nbsp;base,
                                 int&nbsp;destHistoryEmbedLength,
                                 int&nbsp;sourceHistoryEmbeddingLength)</code></th>
<td class="colLast">
<div class="block">Create a new TE calculator for the given base, destination and source history embedding lengths.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(int,int,int,int,int,int)">TransferEntropyCalculatorDiscrete</a></span>&#8203;(int&nbsp;base,
                                 int&nbsp;destHistoryEmbedLength,
                                 int&nbsp;destEmbeddingDelay,
                                 int&nbsp;sourceHistoryEmbeddingLength,
                                 int&nbsp;sourceEmbeddingDelay,
                                 int&nbsp;delay)</code></th>
<td class="colLast">
<div class="block">Create a new TE calculator for the given base, destination and source history embedding lengths
  and delays.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addObservations(int%5B%5D%5B%5D%5B%5D,int,int)">addObservations</a></span>&#8203;(int[][][]&nbsp;states,
               int&nbsp;h,
               int&nbsp;j)</code></th>
<td class="colLast">
<div class="block">Add observations in to our estimates of the PDFs,
 from a multivariate time-series.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addObservations(int%5B%5D%5B%5D%5B%5D,int,int,int,int)">addObservations</a></span>&#8203;(int[][][]&nbsp;states,
               int&nbsp;sourceRowIndex,
               int&nbsp;sourceColumnIndex,
               int&nbsp;destRowIndex,
               int&nbsp;destColumnIndex)</code></th>
<td class="colLast">
<div class="block">Add observations for a single source-destination pair of the multi-agent system
  to our estimates of the pdfs.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addObservations(int%5B%5D%5B%5D,int)">addObservations</a></span>&#8203;(int[][]&nbsp;states,
               int&nbsp;j)</code></th>
<td class="colLast">
<div class="block">Add observations in to our estimates of the PDFs,
 from a multivariate time-series.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addObservations(int%5B%5D%5B%5D,int,int)">addObservations</a></span>&#8203;(int[][]&nbsp;states,
               int&nbsp;sourceIndex,
               int&nbsp;destIndex)</code></th>
<td class="colLast">
<div class="block">Add observations for a single source-destination pair of the multi-agent system
  to our estimates of the pdfs.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addObservations(int%5B%5D,int%5B%5D)">addObservations</a></span>&#8203;(int[]&nbsp;source,
               int[]&nbsp;dest)</code></th>
<td class="colLast">
<div class="block">Adds a new set of observations to update the PDFs with.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addObservations(int%5B%5D,int%5B%5D,boolean%5B%5D)">addObservations</a></span>&#8203;(int[]&nbsp;source,
               int[]&nbsp;dest,
               boolean[]&nbsp;valid)</code></th>
<td class="colLast">
<div class="block">Add observations for a single source-destination pair 
  to our estimates of the pdfs.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addObservations(int%5B%5D,int%5B%5D,int,int)">addObservations</a></span>&#8203;(int[]&nbsp;source,
               int[]&nbsp;dest,
               int&nbsp;startTime,
               int&nbsp;endTime)</code></th>
<td class="colLast">
<div class="block">Add observations for a single source-destination pair
  to our estimates of the pdfs.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeAverageActiveInfoStorageOfObservations()">computeAverageActiveInfoStorageOfObservations</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the average active information storage from
  the observed values which have been passed in previously.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeAverageLocal(int%5B%5D%5B%5D%5B%5D,int,int)">computeAverageLocal</a></span>&#8203;(int[][][]&nbsp;states,
                   int&nbsp;h,
                   int&nbsp;j)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute average local transfer entropy across a 3D spatiotemporal
  array of the states of homogeneous agents
 Return the average.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeAverageLocal(int%5B%5D%5B%5D%5B%5D,int,int,int,int)">computeAverageLocal</a></span>&#8203;(int[][][]&nbsp;states,
                   int&nbsp;sourceRowIndex,
                   int&nbsp;sourceColumnIndex,
                   int&nbsp;destRowIndex,
                   int&nbsp;destColumnIndex)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute local transfer entropy between specific variables in
 a 3D spatiotemporal multivariate time-series.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeAverageLocal(int%5B%5D%5B%5D,int)">computeAverageLocal</a></span>&#8203;(int[][]&nbsp;states,
                   int&nbsp;j)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute average local transfer entropy across a 2D spatiotemporal
  array of the states of homogeneous agents
 Return the average TE.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeAverageLocal(int%5B%5D%5B%5D,int,int)">computeAverageLocal</a></span>&#8203;(int[][]&nbsp;states,
                   int&nbsp;sourceCol,
                   int&nbsp;destCol)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute local transfer entropy between specific variables in
 a 2D spatiotemporal multivariate time-series.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeAverageLocalOfObservations()">computeAverageLocalOfObservations</a></span>()</code></th>
<td class="colLast">
<div class="block">Compute the average value of the measure
 from the previously-supplied samples.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>double[][][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocal(int%5B%5D%5B%5D%5B%5D,int,int)">computeLocal</a></span>&#8203;(int[][][]&nbsp;states,
            int&nbsp;h,
            int&nbsp;j)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute local transfer entropy across a 3D spatiotemporal
  array of the states of homogeneous agents.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocal(int%5B%5D%5B%5D%5B%5D,int,int,int,int)">computeLocal</a></span>&#8203;(int[][][]&nbsp;states,
            int&nbsp;sourceRowIndex,
            int&nbsp;sourceColumnIndex,
            int&nbsp;destRowIndex,
            int&nbsp;destColumnIndex)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 computes local transfer for the given
  single source-destination pair of the 3D multi-agent system.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocal(int%5B%5D%5B%5D,int)">computeLocal</a></span>&#8203;(int[][]&nbsp;states,
            int&nbsp;j)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute local transfer entropy across a 2D spatiotemporal
  array of the states of homogeneous agents.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocal(int%5B%5D%5B%5D,int,int)">computeLocal</a></span>&#8203;(int[][]&nbsp;states,
            int&nbsp;sourceCol,
            int&nbsp;destCol)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute local transfer entropy between specific variables in
 a 2D spatiotemporal multivariate time-series.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocal(int%5B%5D,int%5B%5D)">computeLocal</a></span>&#8203;(int[]&nbsp;sourceStates,
            int[]&nbsp;destStates)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute local transfer entropy between two time series
 Return a time series of local values.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>double[][][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocalFromPreviousObservations(int%5B%5D%5B%5D%5B%5D,int,int)">computeLocalFromPreviousObservations</a></span>&#8203;(int[][][]&nbsp;states,
                                    int&nbsp;h,
                                    int&nbsp;j)</code></th>
<td class="colLast">
<div class="block">Computes local transfer for the given
  states, using pdfs built up from observations previously
  sent in via the addObservations method.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocalFromPreviousObservations(int%5B%5D%5B%5D%5B%5D,int,int,int,int)">computeLocalFromPreviousObservations</a></span>&#8203;(int[][][]&nbsp;states,
                                    int&nbsp;sourceRowIndex,
                                    int&nbsp;sourceColumnIndex,
                                    int&nbsp;destRowIndex,
                                    int&nbsp;destColumnIndex)</code></th>
<td class="colLast">
<div class="block">Computes local transfer for the given
  single source-destination pair of the multi-agent system,
  using pdfs built up from observations previously
  sent in via the addObservations method.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocalFromPreviousObservations(int%5B%5D%5B%5D,int)">computeLocalFromPreviousObservations</a></span>&#8203;(int[][]&nbsp;states,
                                    int&nbsp;j)</code></th>
<td class="colLast">
<div class="block">Computes local transfer for the given
  multivariate states, using pdfs built up from observations previously
  sent in via the addObservations method.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocalFromPreviousObservations(int%5B%5D%5B%5D,int,int)">computeLocalFromPreviousObservations</a></span>&#8203;(int[][]&nbsp;states,
                                    int&nbsp;sourceIndex,
                                    int&nbsp;destIndex)</code></th>
<td class="colLast">
<div class="block">Computes local transfer for the given
  single source-destination pair of the multi-agent system,
  using pdfs built up from observations previously
  sent in via the addObservations methods.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocalFromPreviousObservations(int%5B%5D,int%5B%5D)">computeLocalFromPreviousObservations</a></span>&#8203;(int[]&nbsp;source,
                                    int[]&nbsp;dest)</code></th>
<td class="colLast">
<div class="block">Computes local apparent transfer entropy for the given
  states, using PDFs built up from observations previously
  sent in via the addObservations method.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocalFromPreviousObservations(int,int,int)">computeLocalFromPreviousObservations</a></span>&#8203;(int&nbsp;sourceCurrent,
                                    int&nbsp;destNext,
                                    int&nbsp;destPast)</code></th>
<td class="colLast">
<div class="block">Computes local transfer entropy for the given values
 
 See <a href="#getPastCount(int)"><code>getPastCount(int)</code></a> for how the joint values representing the past are calculated.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code><a href="../../utils/AnalyticMeasurementDistribution.html" title="class in infodynamics.utils">AnalyticMeasurementDistribution</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeSignificance()">computeSignificance</a></span>()</code></th>
<td class="colLast">
<div class="block">Generate an <b>analytic</b> distribution of what a given measure would look like,
 under a null hypothesis that the source values of our
 samples had no relation to the destination value (possibly
 in the context of a conditional value).</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code><a href="../../utils/EmpiricalMeasurementDistribution.html" title="class in infodynamics.utils">EmpiricalMeasurementDistribution</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeSignificance(int)">computeSignificance</a></span>&#8203;(int&nbsp;numPermutationsToCheck)</code></th>
<td class="colLast">
<div class="block">Generate an <b>empirical</b> (bootstrapped) distribution of what the given measure would look like,
 under a null hypothesis that the source values of our
 samples had no relation to the destination value (possibly
 in the context of a conditional value).</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code><a href="../../utils/EmpiricalMeasurementDistribution.html" title="class in infodynamics.utils">EmpiricalMeasurementDistribution</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeSignificance(int%5B%5D%5B%5D)">computeSignificance</a></span>&#8203;(int[][]&nbsp;newOrderings)</code></th>
<td class="colLast">
<div class="block">Generate an <b>empirical</b> (bootstrapped) distribution of what the given measure would look like,
 under a null hypothesis that the source values of our
 samples had no relation to the destination value (possibly
 in the context of a conditional value).</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#debugPrintObservations()">debugPrintObservations</a></span>()</code></th>
<td class="colLast">
<div class="block">Dump a debug print of the PDFs of our observations</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNextCount(int)">getNextCount</a></span>&#8203;(int&nbsp;destVal)</code></th>
<td class="colLast">
<div class="block">Returns the count of observations of the next state dest[n+1].</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNextPastCount(int,int)">getNextPastCount</a></span>&#8203;(int&nbsp;destVal,
                int&nbsp;pastVal)</code></th>
<td class="colLast">
<div class="block">Returns the count of observations of the past given past state and next value.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNextPastProbability(int,int)">getNextPastProbability</a></span>&#8203;(int&nbsp;destVal,
                      int&nbsp;pastVal)</code></th>
<td class="colLast">
<div class="block">Returns the probability of the past given past state and next value.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getNextProbability(int)">getNextProbability</a></span>&#8203;(int&nbsp;destVal)</code></th>
<td class="colLast">
<div class="block">Returns the probability of the next state dest[n+1].</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPastCount(int)">getPastCount</a></span>&#8203;(int&nbsp;pastVal)</code></th>
<td class="colLast">
<div class="block">Returns the count of observations of the supplied past state
  pastVal.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPastProbability(int)">getPastProbability</a></span>&#8203;(int&nbsp;pastVal)</code></th>
<td class="colLast">
<div class="block">Returns the probability of the supplied past state
  pastVal.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSourceNextPastCount(int,int,int)">getSourceNextPastCount</a></span>&#8203;(int&nbsp;sourceVal,
                      int&nbsp;destVal,
                      int&nbsp;pastVal)</code></th>
<td class="colLast">
<div class="block">Returns the count of observations of the past given state dest[n]^k,
  the next state of the destination dest[n+1] and the source state source[n]^l.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSourceNextPastProbability(int,int,int)">getSourceNextPastProbability</a></span>&#8203;(int&nbsp;sourceVal,
                            int&nbsp;destVal,
                            int&nbsp;pastVal)</code></th>
<td class="colLast">
<div class="block">Returns the probability of the past given state dest[n]^k,
  the next state of the destination dest[n+1] and the source state source[n]^l.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSourcePastCount(int,int)">getSourcePastCount</a></span>&#8203;(int&nbsp;sourceVal,
                  int&nbsp;pastVal)</code></th>
<td class="colLast">
<div class="block">Returns the count of observations of the past given state dest[n]^k and the source state source[n]^l.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getSourcePastProbability(int,int)">getSourcePastProbability</a></span>&#8203;(int&nbsp;sourceVal,
                        int&nbsp;pastVal)</code></th>
<td class="colLast">
<div class="block">Returns the probability of the past given state dest[n]^k and the source state source[n]^l.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initialise()">initialise</a></span>()</code></th>
<td class="colLast">
<div class="block">Initialise the calculator for re-use with new observations.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initialise(int,int,int,int,int,int)">initialise</a></span>&#8203;(int&nbsp;base,
          int&nbsp;destHistoryEmbedLength,
          int&nbsp;destEmbeddingDelay,
          int&nbsp;sourceHistoryEmbeddingLength,
          int&nbsp;sourceEmbeddingDelay,
          int&nbsp;delay)</code></th>
<td class="colLast">
<div class="block">Initialise with (potentially) new parameters</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isPeriodicBoundaryConditions()">isPeriodicBoundaryConditions</a></span>()</code></th>
<td class="colLast">
<div class="block">Whether we assume periodic boundary conditions in the calls
  for homogeneous variables.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static <a href="TransferEntropyCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">TransferEntropyCalculatorDiscrete</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#newInstance(int,int)">newInstance</a></span>&#8203;(int&nbsp;base,
           int&nbsp;destHistoryEmbedLength)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setPeriodicBoundaryConditions(boolean)">setPeriodicBoundaryConditions</a></span>&#8203;(boolean&nbsp;periodicBoundaryConditions)</code></th>
<td class="colLast">
<div class="block">set whether we assume periodic boundary conditions in the calls
  for homogeneous variables.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.infodynamics.measures.discrete.ContextOfPastMeasureCalculatorDiscrete">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;infodynamics.measures.discrete.<a href="ContextOfPastMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">ContextOfPastMeasureCalculatorDiscrete</a></h3>
<code><a href="ContextOfPastMeasureCalculatorDiscrete.html#computePastValue(int%5B%5D%5B%5D%5B%5D,int,int,int)">computePastValue</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#computePastValue(int%5B%5D%5B%5D,int,int)">computePastValue</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#computePastValue(int%5B%5D,int)">computePastValue</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#initialise(int,int)">initialise</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.infodynamics.measures.discrete.InfoMeasureCalculatorDiscrete">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;infodynamics.measures.discrete.<a href="InfoMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">InfoMeasureCalculatorDiscrete</a></h3>
<code><a href="InfoMeasureCalculatorDiscrete.html#getLastAverage()">getLastAverage</a>, <a href="InfoMeasureCalculatorDiscrete.html#getLastMax()">getLastMax</a>, <a href="InfoMeasureCalculatorDiscrete.html#getLastMin()">getLastMin</a>, <a href="InfoMeasureCalculatorDiscrete.html#getLastStd()">getLastStd</a>, <a href="InfoMeasureCalculatorDiscrete.html#getNumObservations()">getNumObservations</a>, <a href="InfoMeasureCalculatorDiscrete.html#initialise(int)">initialise</a>, <a href="InfoMeasureCalculatorDiscrete.html#isPowerOf2(int)">isPowerOf2</a>, <a href="InfoMeasureCalculatorDiscrete.html#resetBase(int)">resetBase</a>, <a href="InfoMeasureCalculatorDiscrete.html#setDebug(boolean)">setDebug</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="sourceNextPastCount">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sourceNextPastCount</h4>
<pre>protected&nbsp;int[][][] sourceNextPastCount</pre>
<div class="block">Counts of (source,dest_next,dest_embedded_past) tuples</div>
</li>
</ul>
<a id="sourcePastCount">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sourcePastCount</h4>
<pre>protected&nbsp;int[][] sourcePastCount</pre>
<div class="block">Counts of (source,dest_embedded_past) tuples</div>
</li>
</ul>
<a id="periodicBoundaryConditions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>periodicBoundaryConditions</h4>
<pre>protected&nbsp;boolean periodicBoundaryConditions</pre>
<div class="block">Whether to assume periodic boundary conditions for channels across
  the boundary of the multidimensional
  calls supplying observations, e.g.
  <a href="#addObservations(int%5B%5D%5B%5D,int)"><code>addObservations(int[][], int)</code></a> calls</div>
</li>
</ul>
<a id="destEmbeddingDelay">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>destEmbeddingDelay</h4>
<pre>protected&nbsp;int destEmbeddingDelay</pre>
<div class="block">Embedding delay for the destination variable,
  i.e. time lag between each sample in the past</div>
</li>
</ul>
<a id="sourceHistoryEmbedLength">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sourceHistoryEmbedLength</h4>
<pre>protected&nbsp;int sourceHistoryEmbedLength</pre>
<div class="block">Embedding length of the source variable.
 This is "l" in Schreiber's notation.</div>
</li>
</ul>
<a id="sourceEmbeddingDelay">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sourceEmbeddingDelay</h4>
<pre>protected&nbsp;int sourceEmbeddingDelay</pre>
<div class="block">Embedding delay for the source variable,
  i.e. time lag between each sample in the past</div>
</li>
</ul>
<a id="delay">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delay</h4>
<pre>protected&nbsp;int delay</pre>
<div class="block">Source-destination delay to consider the information transfer across</div>
</li>
</ul>
<a id="base_power_l">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>base_power_l</h4>
<pre>protected&nbsp;int base_power_l</pre>
<div class="block">A cached value of base^sourceHistoryEmbedLength</div>
</li>
</ul>
<a id="maxShiftedSourceValue">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maxShiftedSourceValue</h4>
<pre>protected&nbsp;int[] maxShiftedSourceValue</pre>
<div class="block">A cached value of each discrete value left shifted (in "base" counting) by (sourceHistoryEmbedLength-1).</div>
</li>
</ul>
<a id="startObservationTime">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startObservationTime</h4>
<pre>protected&nbsp;int startObservationTime</pre>
<div class="block">First time step at which we can take an observation
  (needs to account for an embedding in the previous steps)</div>
</li>
</ul>
<a id="estimateComputed">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>estimateComputed</h4>
<pre>protected&nbsp;boolean estimateComputed</pre>
<div class="block">Tracks whether the measure has been computed since the last initialisation</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TransferEntropyCalculatorDiscrete</h4>
<pre>public&nbsp;TransferEntropyCalculatorDiscrete()</pre>
<div class="block">Create a new TE calculator with all parameters as default
 (base 2 and all embedding/delay parameters 1)</div>
</li>
</ul>
<a id="&lt;init&gt;(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TransferEntropyCalculatorDiscrete</h4>
<pre>public&nbsp;TransferEntropyCalculatorDiscrete&#8203;(int&nbsp;base,
                                         int&nbsp;destHistoryEmbedLength)</pre>
<div class="block">Create a new TE calculator for the given base and destination history embedding length
  (leave the other embedding parameters as default)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>base</code> - number of symbols for each variable.
        E.g. binary variables are in base-2.</dd>
<dd><code>destHistoryEmbedLength</code> - embedded history length of the destination to condition on -
        this is k in Schreiber's notation.</dd>
</dl>
</li>
</ul>
<a id="&lt;init&gt;(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TransferEntropyCalculatorDiscrete</h4>
<pre>public&nbsp;TransferEntropyCalculatorDiscrete&#8203;(int&nbsp;base,
                                         int&nbsp;destHistoryEmbedLength,
                                         int&nbsp;sourceHistoryEmbeddingLength)</pre>
<div class="block">Create a new TE calculator for the given base, destination and source history embedding lengths.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>base</code> - number of quantisation levels for each variable.
        E.g. binary variables are in base-2.</dd>
<dd><code>destHistoryEmbedLength</code> - embedded history length of the destination to condition on -
        this is k in Schreiber's notation.</dd>
<dd><code>sourceHistoryEmbeddingLength</code> - embedded history length of the source to include -
        this is l in Schreiber's notation.</dd>
</dl>
</li>
</ul>
<a id="&lt;init&gt;(int,int,int,int,int,int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>TransferEntropyCalculatorDiscrete</h4>
<pre>public&nbsp;TransferEntropyCalculatorDiscrete&#8203;(int&nbsp;base,
                                         int&nbsp;destHistoryEmbedLength,
                                         int&nbsp;destEmbeddingDelay,
                                         int&nbsp;sourceHistoryEmbeddingLength,
                                         int&nbsp;sourceEmbeddingDelay,
                                         int&nbsp;delay)</pre>
<div class="block">Create a new TE calculator for the given base, destination and source history embedding lengths
  and delays.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>base</code> - number of quantisation levels for each variable.
        E.g. binary variables are in base-2.</dd>
<dd><code>destHistoryEmbedLength</code> - embedded history length of the destination to condition on -
        this is k in Schreiber's notation.</dd>
<dd><code>destEmbeddingDelay</code> - embedding delay of the destination for conditioning on -
        this is the delay between each of the k samples from the past history</dd>
<dd><code>sourceHistoryEmbeddingLength</code> - embedded history length of the source to include -
        this is l in Schreiber's notation.</dd>
<dd><code>sourceEmbeddingDelay</code> - embedding delay of the source -
        this is the delay between each of the l samples from the past history</dd>
<dd><code>delay</code> - source-destination delay to consider the information transfer across
                  (should be >= 0, default is 1)</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="newInstance(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newInstance</h4>
<pre class="methodSignature">public static&nbsp;<a href="TransferEntropyCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">TransferEntropyCalculatorDiscrete</a>&nbsp;newInstance&#8203;(int&nbsp;base,
                                                            int&nbsp;destHistoryEmbedLength)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span></div>
<div class="block">User was formerly forced to create new instances through this factory method.
 Retained for backwards compatibility.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>base</code> - </dd>
<dd><code>destHistoryEmbedLength</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new TransferEntropyCalculator object</dd>
</dl>
</li>
</ul>
<a id="initialise(int,int,int,int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initialise</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;initialise&#8203;(int&nbsp;base,
                       int&nbsp;destHistoryEmbedLength,
                       int&nbsp;destEmbeddingDelay,
                       int&nbsp;sourceHistoryEmbeddingLength,
                       int&nbsp;sourceEmbeddingDelay,
                       int&nbsp;delay)</pre>
<div class="block">Initialise with (potentially) new parameters</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>base</code> - </dd>
<dd><code>destHistoryEmbedLength</code> - </dd>
<dd><code>destEmbeddingDelay</code> - </dd>
<dd><code>sourceHistoryEmbeddingLength</code> - </dd>
<dd><code>sourceEmbeddingDelay</code> - </dd>
<dd><code>delay</code> - </dd>
</dl>
</li>
</ul>
<a id="initialise()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initialise</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;initialise()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="InfoMeasureCalculatorDiscrete.html#initialise()">InfoMeasureCalculatorDiscrete</a></code></span></div>
<div class="block">Initialise the calculator for re-use with new observations.
 (Child classes should clear the existing PDFs)</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ChannelCalculatorDiscrete.html#initialise()">initialise</a></code>&nbsp;in interface&nbsp;<code><a href="ChannelCalculatorDiscrete.html" title="interface in infodynamics.measures.discrete">ChannelCalculatorDiscrete</a></code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="ContextOfPastMeasureCalculatorDiscrete.html#initialise()">initialise</a></code>&nbsp;in class&nbsp;<code><a href="ContextOfPastMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">ContextOfPastMeasureCalculatorDiscrete</a></code></dd>
</dl>
</li>
</ul>
<a id="addObservations(int[],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addObservations</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addObservations&#8203;(int[]&nbsp;source,
                            int[]&nbsp;dest)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ChannelCalculatorDiscrete.html#addObservations(int%5B%5D,int%5B%5D)">ChannelCalculatorDiscrete</a></code></span></div>
<div class="block"><p>Adds a new set of observations to update the PDFs with.
 It is intended to be called multiple times.
 
 <p><b>Important:</b> this does not append these observations to the previously
  supplied observations, but treats them independently - i.e. measurements
  such as the transfer entropy will not join them up to examine k
  consecutive values in time.</p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ChannelCalculatorDiscrete.html#addObservations(int%5B%5D,int%5B%5D)">addObservations</a></code>&nbsp;in interface&nbsp;<code><a href="ChannelCalculatorDiscrete.html" title="interface in infodynamics.measures.discrete">ChannelCalculatorDiscrete</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - series of observations for the source variable.</dd>
</dl>
</li>
</ul>
<a id="addObservations(int[],int[],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addObservations</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addObservations&#8203;(int[]&nbsp;source,
                            int[]&nbsp;dest,
                            int&nbsp;startTime,
                            int&nbsp;endTime)</pre>
<div class="block">Add observations for a single source-destination pair
  to our estimates of the pdfs.
 Start and end time are the (inclusive) indices within which to add the observations.
 The start time is from the earliest of the k historical values of the destination (inclusive),
  the end time is the last destination time point to add in.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - source time-series</dd>
<dd><code>dest</code> - destination time-series. 
  Must be same length as source</dd>
<dd><code>startTime</code> - earliest time that we may extract embedded history from</dd>
<dd><code>endTime</code> - last destination (next) time point to add in</dd>
</dl>
</li>
</ul>
<a id="addObservations(int[],int[],boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addObservations</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addObservations&#8203;(int[]&nbsp;source,
                            int[]&nbsp;dest,
                            boolean[]&nbsp;valid)</pre>
<div class="block">Add observations for a single source-destination pair 
  to our estimates of the pdfs.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - source time-series</dd>
<dd><code>dest</code> - destination time-series. 
  Must be same length as source</dd>
<dd><code>valid</code> - time-series of whether the signals
  at the given time should be considered valid 
  and added to our PDFs. We don't include any embedding vectors which
  stretch across any invalid points, even if these invalid points
  are not specifically sampled for the embedding vector.</dd>
</dl>
</li>
</ul>
<a id="addObservations(int[][],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addObservations</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addObservations&#8203;(int[][]&nbsp;states,
                            int&nbsp;j)</pre>
<div class="block">Add observations in to our estimates of the PDFs,
 from a multivariate time-series.
 This call suitable only for homogeneous variables, as all
  variable pairs separated by j column will contribute to the PDFs.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable number)</dd>
<dd><code>j</code> - - number of columns to compute transfer entropy across
        (i.e. source is column i-j, dest is column i: we
  compute transfer is j cells to the right, using observations
  across all column pairs separated by j)</dd>
</dl>
</li>
</ul>
<a id="addObservations(int[][][],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addObservations</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addObservations&#8203;(int[][][]&nbsp;states,
                            int&nbsp;h,
                            int&nbsp;j)</pre>
<div class="block">Add observations in to our estimates of the PDFs,
 from a multivariate time-series.
 This call suitable only for homogeneous agents, as all
  variable pairs separated by h rows and j columns
  will contribute to the PDFs.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable row number,
  3rd is variable column number)</dd>
<dd><code>h</code> - - number of rows to compute transfer entropy across
        (i.e. source is in row i-h, dest is column i)</dd>
<dd><code>j</code> - - number of columns to compute transfer entropy across
        (i.e. source is column i-j, dest is column i)</dd>
</dl>
</li>
</ul>
<a id="addObservations(int[][],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addObservations</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addObservations&#8203;(int[][]&nbsp;states,
                            int&nbsp;sourceIndex,
                            int&nbsp;destIndex)</pre>
<div class="block">Add observations for a single source-destination pair of the multi-agent system
  to our estimates of the pdfs.
 This call should be made as opposed to <a href="#addObservations(int%5B%5D%5B%5D,int)"><code>addObservations(int[][], int)</code></a>
  for computing TE for heterogeneous agents.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ChannelCalculatorDiscrete.html#addObservations(int%5B%5D%5B%5D,int,int)">addObservations</a></code>&nbsp;in interface&nbsp;<code><a href="ChannelCalculatorDiscrete.html" title="interface in infodynamics.measures.discrete">ChannelCalculatorDiscrete</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable number)</dd>
<dd><code>sourceIndex</code> - source variable index in states</dd>
<dd><code>destIndex</code> - destination variable index in states</dd>
</dl>
</li>
</ul>
<a id="addObservations(int[][][],int,int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addObservations</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addObservations&#8203;(int[][][]&nbsp;states,
                            int&nbsp;sourceRowIndex,
                            int&nbsp;sourceColumnIndex,
                            int&nbsp;destRowIndex,
                            int&nbsp;destColumnIndex)</pre>
<div class="block">Add observations for a single source-destination pair of the multi-agent system
  to our estimates of the pdfs.
 This call should be made as opposed to <a href="#addObservations(int%5B%5D%5B%5D%5B%5D,int,int)"><code>addObservations(int[][][], int, int)</code></a>
  for computing TE for heterogeneous agents.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable row number,
  3rd is variable column number)</dd>
<dd><code>sourceRowIndex</code> - source variable row index in states</dd>
<dd><code>sourceColumnIndex</code> - source variable column index in states</dd>
<dd><code>destRowIndex</code> - destination variable row index in states</dd>
<dd><code>destColumnIndex</code> - destination variable column index in states</dd>
</dl>
</li>
</ul>
<a id="getPastCount(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPastCount</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getPastCount&#8203;(int&nbsp;pastVal)</pre>
<div class="block">Returns the count of observations of the supplied past state
  pastVal.
 The past state is indicated by a unique discrete integer representing the joint variable
  of the k past states: (dest[n-k+1],dest[n-k+2],...,dest[n-1],dest[n]).
 The integer is computed as:<br/>
 pastVal = dest[n-k+1] * base^(k-1) + dest[n-k+2] * base^(k-2) + ... + dest[n-1] * base + dest[n]</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pastVal</code> - int representing the joint state of the past of the destination dest[n]^k</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of observations of this given past state</dd>
</dl>
</li>
</ul>
<a id="getPastProbability(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPastProbability</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getPastProbability&#8203;(int&nbsp;pastVal)</pre>
<div class="block">Returns the probability of the supplied past state
  pastVal.
 See <a href="#getPastCount(int)"><code>getPastCount(int)</code></a> for how the joint value representing the past is calculated.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pastVal</code> - int representing the joint state of the past of the destination dest[n]^k</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>probability of the given past state</dd>
</dl>
</li>
</ul>
<a id="getNextPastCount(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNextPastCount</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getNextPastCount&#8203;(int&nbsp;destVal,
                            int&nbsp;pastVal)</pre>
<div class="block">Returns the count of observations of the past given past state and next value.
 
 See <a href="#getPastCount(int)"><code>getPastCount(int)</code></a> for how the joint value representing the past is calculated.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>destVal</code> - next state of the destination dest[n+1]</dd>
<dd><code>pastVal</code> - int representing the joint state of the past of the destination dest[n]^k</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of observations of the given past state and next state</dd>
</dl>
</li>
</ul>
<a id="getNextPastProbability(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNextPastProbability</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getNextPastProbability&#8203;(int&nbsp;destVal,
                                     int&nbsp;pastVal)</pre>
<div class="block">Returns the probability of the past given past state and next value.
 
 See <a href="#getPastCount(int)"><code>getPastCount(int)</code></a> for how the joint value representing the past is calculated.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>destVal</code> - next state of the destination dest[n+1]</dd>
<dd><code>pastVal</code> - int representing the joint state of the past of the destination dest[n]^k</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>probability of the given past state and next state</dd>
</dl>
</li>
</ul>
<a id="getSourcePastCount(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSourcePastCount</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getSourcePastCount&#8203;(int&nbsp;sourceVal,
                              int&nbsp;pastVal)</pre>
<div class="block">Returns the count of observations of the past given state dest[n]^k and the source state source[n]^l.
 
 See <a href="#getPastCount(int)"><code>getPastCount(int)</code></a> for how the joint values representing the past states are calculated.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourceVal</code> - int representing the joint state of the source source[n]^l</dd>
<dd><code>pastVal</code> - int representing the joint state of the past of the destination dest[n]^k</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of observations of the given past state and the source state</dd>
</dl>
</li>
</ul>
<a id="getSourcePastProbability(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSourcePastProbability</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getSourcePastProbability&#8203;(int&nbsp;sourceVal,
                                       int&nbsp;pastVal)</pre>
<div class="block">Returns the probability of the past given state dest[n]^k and the source state source[n]^l.
 
 See <a href="#getPastCount(int)"><code>getPastCount(int)</code></a> for how the joint values representing the past states are calculated.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourceVal</code> - int representing the joint state of the source source[n]^l</dd>
<dd><code>pastVal</code> - int representing the joint state of the past of the destination dest[n]^k</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>probability of the given past state and the source state</dd>
</dl>
</li>
</ul>
<a id="getSourceNextPastCount(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSourceNextPastCount</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getSourceNextPastCount&#8203;(int&nbsp;sourceVal,
                                  int&nbsp;destVal,
                                  int&nbsp;pastVal)</pre>
<div class="block">Returns the count of observations of the past given state dest[n]^k,
  the next state of the destination dest[n+1] and the source state source[n]^l.
  
 See <a href="#getPastCount(int)"><code>getPastCount(int)</code></a> for how the joint values representing the past states are calculated.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourceVal</code> - int representing the joint state of the source source[n]^l</dd>
<dd><code>nextVal</code> - next state of the destination dest[n+1]</dd>
<dd><code>pastVal</code> - int representing the joint state of the past of the destination dest[n]^k</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of observations of the given past state, next state of destination and the source state</dd>
</dl>
</li>
</ul>
<a id="getSourceNextPastProbability(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSourceNextPastProbability</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getSourceNextPastProbability&#8203;(int&nbsp;sourceVal,
                                           int&nbsp;destVal,
                                           int&nbsp;pastVal)</pre>
<div class="block">Returns the probability of the past given state dest[n]^k,
  the next state of the destination dest[n+1] and the source state source[n]^l.
  
 See <a href="#getPastCount(int)"><code>getPastCount(int)</code></a> for how the joint values representing the past states are calculated.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourceVal</code> - int representing the joint state of the source source[n]^l</dd>
<dd><code>nextVal</code> - next state of the destination dest[n+1]</dd>
<dd><code>pastVal</code> - int representing the joint state of the past of the destination dest[n]^k</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>probability of the given past state, next state of destination and the source state</dd>
</dl>
</li>
</ul>
<a id="getNextCount(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNextCount</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;getNextCount&#8203;(int&nbsp;destVal)</pre>
<div class="block">Returns the count of observations of the next state dest[n+1].</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nextVal</code> - next state of the destination dest[n+1]</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of observations of the given next state</dd>
</dl>
</li>
</ul>
<a id="getNextProbability(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNextProbability</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getNextProbability&#8203;(int&nbsp;destVal)</pre>
<div class="block">Returns the probability of the next state dest[n+1].</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nextVal</code> - state of the next destination dest[n+1]</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>probability of the given next state</dd>
</dl>
</li>
</ul>
<a id="computeAverageLocalOfObservations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAverageLocalOfObservations</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeAverageLocalOfObservations()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="InfoMeasureCalculatorDiscrete.html#computeAverageLocalOfObservations()">InfoMeasureCalculatorDiscrete</a></code></span></div>
<div class="block">Compute the average value of the measure
 from the previously-supplied samples.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ChannelCalculatorDiscrete.html#computeAverageLocalOfObservations()">computeAverageLocalOfObservations</a></code>&nbsp;in interface&nbsp;<code><a href="ChannelCalculatorDiscrete.html" title="interface in infodynamics.measures.discrete">ChannelCalculatorDiscrete</a></code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="InfoMeasureCalculatorDiscrete.html#computeAverageLocalOfObservations()">computeAverageLocalOfObservations</a></code>&nbsp;in class&nbsp;<code><a href="InfoMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">InfoMeasureCalculatorDiscrete</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the estimate of the measure</dd>
</dl>
</li>
</ul>
<a id="computeAverageActiveInfoStorageOfObservations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAverageActiveInfoStorageOfObservations</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeAverageActiveInfoStorageOfObservations()</pre>
<div class="block">Returns the average active information storage from
  the observed values which have been passed in previously.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="ActiveInformationCalculatorDiscrete.html" title="class in infodynamics.measures.discrete"><code>ActiveInformationCalculatorDiscrete</code></a></dd>
</dl>
</li>
</ul>
<a id="debugPrintObservations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>debugPrintObservations</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;debugPrintObservations()</pre>
<div class="block">Dump a debug print of the PDFs of our observations</div>
</li>
</ul>
<a id="computeSignificance(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeSignificance</h4>
<pre class="methodSignature">public&nbsp;<a href="../../utils/EmpiricalMeasurementDistribution.html" title="class in infodynamics.utils">EmpiricalMeasurementDistribution</a>&nbsp;computeSignificance&#8203;(int&nbsp;numPermutationsToCheck)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../utils/EmpiricalNullDistributionComputer.html#computeSignificance(int)">EmpiricalNullDistributionComputer</a></code></span></div>
<div class="block">Generate an <b>empirical</b> (bootstrapped) distribution of what the given measure would look like,
 under a null hypothesis that the source values of our
 samples had no relation to the destination value (possibly
 in the context of a conditional value).
 
 <p>See Section II.E "Statistical significance testing" of 
 the JIDT paper below for a description of how this is done for MI,
 conditional MI and TE.
 </p>
 
 <p>Note that if several disjoint time-series have been added 
 as observations using addObservations methods etc.,
 then these separate "trials" will be mixed up in the generation
 of surrogates here.</p>
 
 <p><b>References:</b><br/>
  <ul>
   <li>J.T. Lizier, "JIDT: An information-theoretic
    toolkit for studying the dynamics of complex systems", 2014.</li>
 </ul></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../utils/EmpiricalNullDistributionComputer.html#computeSignificance(int)">computeSignificance</a></code>&nbsp;in interface&nbsp;<code><a href="../../utils/EmpiricalNullDistributionComputer.html" title="interface in infodynamics.utils">EmpiricalNullDistributionComputer</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>numPermutationsToCheck</code> - number of surrogate samples to bootstrap
  to generate the distribution.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the empirical distribution of measure scores under this null hypothesis.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd>"J.T. Lizier, 'JIDT: An information-theoretic
    toolkit for studying the dynamics of complex systems', 2014."</dd>
</dl>
</li>
</ul>
<a id="computeSignificance(int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeSignificance</h4>
<pre class="methodSignature">public&nbsp;<a href="../../utils/EmpiricalMeasurementDistribution.html" title="class in infodynamics.utils">EmpiricalMeasurementDistribution</a>&nbsp;computeSignificance&#8203;(int[][]&nbsp;newOrderings)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../utils/EmpiricalNullDistributionComputer.html#computeSignificance(int%5B%5D%5B%5D)">EmpiricalNullDistributionComputer</a></code></span></div>
<div class="block">Generate an <b>empirical</b> (bootstrapped) distribution of what the given measure would look like,
 under a null hypothesis that the source values of our
 samples had no relation to the destination value (possibly
 in the context of a conditional value).
 
 <p>See Section II.E "Statistical significance testing" of 
 the JIDT paper below for a description of how this is done MI,
 conditional MI and TE.
 </p>
 
 <p>Note that if several disjoint time-series have been added 
 as observations using addObservations methods etc.,
 then these separate "trials" will be mixed up in the generation
 of surrogates here.</p>
 
 <p>This method (in contrast to <a href="../../utils/EmpiricalNullDistributionComputer.html#computeSignificance(int)"><code>EmpiricalNullDistributionComputer.computeSignificance(int)</code></a>)
 allows the user to specify how to construct the surrogates,
 such that repeatable results may be obtained.</p>
 
 <p><b>References:</b><br/>
  <ul>
   <li>J.T. Lizier, "JIDT: An information-theoretic
    toolkit for studying the dynamics of complex systems", 2014.</li>
 </ul></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../utils/EmpiricalNullDistributionComputer.html#computeSignificance(int%5B%5D%5B%5D)">computeSignificance</a></code>&nbsp;in interface&nbsp;<code><a href="../../utils/EmpiricalNullDistributionComputer.html" title="interface in infodynamics.utils">EmpiricalNullDistributionComputer</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>newOrderings</code> - a specification of how to shuffle the next values
  to create the surrogates to generate the distribution with. The first
  index is the permutation number (i.e. newOrderings.length is the number
  of surrogate samples we use to bootstrap to generate the distribution here.)
  Each array newOrderings[i] should be an array of length N (where
  would be the value returned by a call to getNumObservations() for the given measure)
  containing a permutation of the values in 0..(N-1).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the empirical distribution of measure scores under this null hypothesis.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd>"J.T. Lizier, 'JIDT: An information-theoretic
    toolkit for studying the dynamics of complex systems', 2014."</dd>
</dl>
</li>
</ul>
<a id="computeSignificance()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeSignificance</h4>
<pre class="methodSignature">public&nbsp;<a href="../../utils/AnalyticMeasurementDistribution.html" title="class in infodynamics.utils">AnalyticMeasurementDistribution</a>&nbsp;computeSignificance()
                                                    throws java.lang.Exception</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../utils/AnalyticNullDistributionComputer.html#computeSignificance()">AnalyticNullDistributionComputer</a></code></span></div>
<div class="block">Generate an <b>analytic</b> distribution of what a given measure would look like,
 under a null hypothesis that the source values of our
 samples had no relation to the destination value (possibly
 in the context of a conditional value).
 
 <p>See Section II.E "Statistical significance testing" of 
 the JIDT paper below for a description of how this is done for MI,
 conditional MI and TE as per the references below.
 </p>
 
 <p><b>References:</b><br/>
  <ul>
   <li>J.T. Lizier, "JIDT: An information-theoretic
    toolkit for studying the dynamics of complex systems", 2014.</li>
         <li>Brillinger, <a href="http://www.stat.berkeley.edu/~brill/Papers/MIBJPS.pdf">
                "Some data analyses using mutual information"</a>,
                Brazilian Journal of Probability and Statistics, <b>18</b>, p. 163, (2004)</li>
         <li>Cheng et al., <a href="http://www.jds-online.com/file_download/112/JDS-369.pdf">
                "Data Information in Contingency Tables: A Fallacy of Hierarchical Loglinear Models"</a>,
                Journal of Data Science, <b>4</b>, p. 387 (2006).</li>
   <li>Geweke, <a href="http://dx.doi.org/10.1080/01621459.1982.10477803">
        "Measurement of Linear Dependence and Feedback between Multiple Time Series"</a>,
        Journal of the American Statistical Association, <b>77</b>, p. 304-313 (1982).</li>
         <li>Barnett and Bossomaier, <a href="http://arxiv.org/abs/1205.6339">
                "Transfer Entropy as a Log-likelihood Ratio"</a>,
                Physical Review Letters, <b>109</b>, p. 138105+ (2012).</li>
 </ul></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../utils/AnalyticNullDistributionComputer.html#computeSignificance()">computeSignificance</a></code>&nbsp;in interface&nbsp;<code><a href="../../utils/AnalyticNullDistributionComputer.html" title="interface in infodynamics.utils">AnalyticNullDistributionComputer</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the analytic distribution of channel measure scores under this null hypothesis.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd>
</dl>
</li>
</ul>
<a id="computeLocalFromPreviousObservations(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocalFromPreviousObservations</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeLocalFromPreviousObservations&#8203;(int&nbsp;sourceCurrent,
                                                   int&nbsp;destNext,
                                                   int&nbsp;destPast)</pre>
<div class="block">Computes local transfer entropy for the given values
 
 See <a href="#getPastCount(int)"><code>getPastCount(int)</code></a> for how the joint values representing the past are calculated.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourceCurrent</code> - int representing the joint state of the source source[n]^l</dd>
<dd><code>destNext</code> - next state of the destination dest[n+1]</dd>
<dd><code>destPast</code> - int representing the joint state of the past of the destination dest[n]^k</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>local TE for the given observation</dd>
</dl>
</li>
</ul>
<a id="computeLocalFromPreviousObservations(int[],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocalFromPreviousObservations</h4>
<pre class="methodSignature">public&nbsp;double[]&nbsp;computeLocalFromPreviousObservations&#8203;(int[]&nbsp;source,
                                                     int[]&nbsp;dest)</pre>
<div class="block">Computes local apparent transfer entropy for the given
  states, using PDFs built up from observations previously
  sent in via the addObservations method.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - source time-series</dd>
<dd><code>dest</code> - destination time-series. 
  Must be same length as source</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>time-series of local TE values</dd>
</dl>
</li>
</ul>
<a id="computeLocalFromPreviousObservations(int[][],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocalFromPreviousObservations</h4>
<pre class="methodSignature">public&nbsp;double[][]&nbsp;computeLocalFromPreviousObservations&#8203;(int[][]&nbsp;states,
                                                       int&nbsp;j)</pre>
<div class="block">Computes local transfer for the given
  multivariate states, using pdfs built up from observations previously
  sent in via the addObservations method.
 This call suitable only for homogeneous agents, as all
  variable pairs separated by j column will
  have their local TE computed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable number)</dd>
<dd><code>j</code> - - number of columns to compute transfer entropy across
        (i.e. source is column i-j, dest is column i: we
  compute transfer is j cells to the right, using observations
  across all column pairs separated by j)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multivariate time series of local TE values
  (first index is time, second index is destination variable)</dd>
</dl>
</li>
</ul>
<a id="computeLocalFromPreviousObservations(int[][][],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocalFromPreviousObservations</h4>
<pre class="methodSignature">public&nbsp;double[][][]&nbsp;computeLocalFromPreviousObservations&#8203;(int[][][]&nbsp;states,
                                                         int&nbsp;h,
                                                         int&nbsp;j)</pre>
<div class="block">Computes local transfer for the given
  states, using pdfs built up from observations previously
  sent in via the addObservations method.
 This call suitable only for homogeneous agents, as all
  variable pairs separated by h rows and j columns
  will have their local TE computed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable row number,
  3rd is variable column number)</dd>
<dd><code>h</code> - - number of rows to compute transfer entropy across
        (i.e. source is in row i-h, dest is column i)</dd>
<dd><code>j</code> - - number of columns to compute transfer entropy across
        (i.e. source is column i-j, dest is column i)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multivariate time series of local TE values
  (first index is time, second index is destination variable
  row number, third is destination variable column number)</dd>
</dl>
</li>
</ul>
<a id="computeLocalFromPreviousObservations(int[][],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocalFromPreviousObservations</h4>
<pre class="methodSignature">public&nbsp;double[]&nbsp;computeLocalFromPreviousObservations&#8203;(int[][]&nbsp;states,
                                                     int&nbsp;sourceIndex,
                                                     int&nbsp;destIndex)</pre>
<div class="block">Computes local transfer for the given
  single source-destination pair of the multi-agent system,
  using pdfs built up from observations previously
  sent in via the addObservations methods.
 This call should be made as opposed to <a href="#addObservations(int%5B%5D%5B%5D,int)"><code>addObservations(int[][], int)</code></a>
  for computing local TE for heterogeneous agents.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable number)</dd>
<dd><code>sourceIndex</code> - source variable index in states</dd>
<dd><code>destIndex</code> - destination variable index in states</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>time-series of local TE values between the series</dd>
</dl>
</li>
</ul>
<a id="computeLocalFromPreviousObservations(int[][][],int,int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocalFromPreviousObservations</h4>
<pre class="methodSignature">public&nbsp;double[]&nbsp;computeLocalFromPreviousObservations&#8203;(int[][][]&nbsp;states,
                                                     int&nbsp;sourceRowIndex,
                                                     int&nbsp;sourceColumnIndex,
                                                     int&nbsp;destRowIndex,
                                                     int&nbsp;destColumnIndex)</pre>
<div class="block">Computes local transfer for the given
  single source-destination pair of the multi-agent system,
  using pdfs built up from observations previously
  sent in via the addObservations method.
 This call should be made as opposed to <a href="#addObservations(int%5B%5D%5B%5D%5B%5D,int,int)"><code>addObservations(int[][][], int, int)</code></a>
  for computing local TE for heterogeneous agents.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable row number,
  3rd is variable column number)</dd>
<dd><code>sourceRowIndex</code> - source variable row index in states</dd>
<dd><code>sourceColumnIndex</code> - source variable column index in states</dd>
<dd><code>destRowIndex</code> - destination variable row index in states</dd>
<dd><code>destColumnIndex</code> - destination variable column index in states</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>time-series of local TE values between the series</dd>
</dl>
</li>
</ul>
<a id="computeLocal(int[],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocal</h4>
<pre class="methodSignature">public&nbsp;double[]&nbsp;computeLocal&#8203;(int[]&nbsp;sourceStates,
                             int[]&nbsp;destStates)</pre>
<div class="block">Standalone routine to 
 compute local transfer entropy between two time series
 Return a time series of local values.
 First max(k,l) values are zeros since TE is not defined there</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourceStates</code> - source time-series</dd>
<dd><code>destStates</code> - destination time-series. 
  Must be same length as sourceStates</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>time-series of local TE values</dd>
</dl>
</li>
</ul>
<a id="computeLocal(int[][],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocal</h4>
<pre class="methodSignature">public&nbsp;double[][]&nbsp;computeLocal&#8203;(int[][]&nbsp;states,
                               int&nbsp;j)</pre>
<div class="block">Standalone routine to 
 compute local transfer entropy across a 2D spatiotemporal
  array of the states of homogeneous agents.
 Return a 2D spatiotemporal array of local values.
 First max(k,l) values are zeros since TE is not defined there.
 This call suitable only for homogeneous agents, as all
  variable pairs separated by j column will
  have their local TE computed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable number)</dd>
<dd><code>j</code> - - number of columns to compute transfer entropy across
        (i.e. source is column i-j, dest is column i: we
  compute transfer is j cells to the right, using observations
  across all column pairs separated by j)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multivariate time series of local TE values
  (first index is time, second index is destination variable)</dd>
</dl>
</li>
</ul>
<a id="computeLocal(int[][][],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocal</h4>
<pre class="methodSignature">public&nbsp;double[][][]&nbsp;computeLocal&#8203;(int[][][]&nbsp;states,
                                 int&nbsp;h,
                                 int&nbsp;j)</pre>
<div class="block">Standalone routine to 
 compute local transfer entropy across a 3D spatiotemporal
  array of the states of homogeneous agents.
 Return a 3D spatiotemporal array of local values.
 First max(k,l) values are zeros since TE is not defined there.
 This call suitable only for homogeneous agents, as all
  variable pairs separated by h rows and j columns
  will have their local TE computed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable row number,
  3rd is variable column number)</dd>
<dd><code>h</code> - - number of rows to compute transfer entropy across
        (i.e. source is in row i-h, dest is column i)</dd>
<dd><code>j</code> - - number of columns to compute transfer entropy across
        (i.e. source is column i-j, dest is column i)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multivariate time series of local TE values
  (first index is time, second index is destination variable
  row number, third is destination variable column number)</dd>
</dl>
</li>
</ul>
<a id="computeAverageLocal(int[][],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAverageLocal</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeAverageLocal&#8203;(int[][]&nbsp;states,
                                  int&nbsp;j)</pre>
<div class="block">Standalone routine to 
 compute average local transfer entropy across a 2D spatiotemporal
  array of the states of homogeneous agents
 Return the average TE.
 This call suitable only for homogeneous agents, as all
  variable pairs separated by j column will
  have their local TE computed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable number)</dd>
<dd><code>j</code> - - number of columns to compute transfer entropy across
        (i.e. source is column i-j, dest is column i: we
  compute transfer is j cells to the right, using observations
  across all column pairs separated by j)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>average TE across j variables to the right</dd>
</dl>
</li>
</ul>
<a id="computeAverageLocal(int[][][],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAverageLocal</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeAverageLocal&#8203;(int[][][]&nbsp;states,
                                  int&nbsp;h,
                                  int&nbsp;j)</pre>
<div class="block">Standalone routine to 
 compute average local transfer entropy across a 3D spatiotemporal
  array of the states of homogeneous agents
 Return the average.
 This call suitable only for homogeneous agents, as all
  variable pairs separated by h rows and j columns
  will have their PDFs combined.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable row number,
  3rd is variable column number)</dd>
<dd><code>h</code> - - number of rows to compute transfer entropy across
        (i.e. source is in row i-h, dest is column i)</dd>
<dd><code>j</code> - - number of columns to compute transfer entropy across
        (i.e. source is column i-j, dest is column i)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="computeLocal(int[][],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocal</h4>
<pre class="methodSignature">public&nbsp;double[]&nbsp;computeLocal&#8203;(int[][]&nbsp;states,
                             int&nbsp;sourceCol,
                             int&nbsp;destCol)</pre>
<div class="block">Standalone routine to 
 compute local transfer entropy between specific variables in
 a 2D spatiotemporal multivariate time-series.
 First max(k,l) values are zeros since TE is not defined there.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable number)</dd>
<dd><code>sourceCol</code> - source variable index in states</dd>
<dd><code>destCol</code> - destination variable index in states</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>time-series of local TE values between the series</dd>
</dl>
</li>
</ul>
<a id="computeLocal(int[][][],int,int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocal</h4>
<pre class="methodSignature">public&nbsp;double[]&nbsp;computeLocal&#8203;(int[][][]&nbsp;states,
                             int&nbsp;sourceRowIndex,
                             int&nbsp;sourceColumnIndex,
                             int&nbsp;destRowIndex,
                             int&nbsp;destColumnIndex)</pre>
<div class="block">Standalone routine to 
 computes local transfer for the given
  single source-destination pair of the 3D multi-agent system.
 This method suitable for heterogeneous variables.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable row number,
  3rd is variable column number)</dd>
<dd><code>sourceRowIndex</code> - source variable row index in states</dd>
<dd><code>sourceColumnIndex</code> - source variable column index in states</dd>
<dd><code>destRowIndex</code> - destination variable row index in states</dd>
<dd><code>destColumnIndex</code> - destination variable column index in states</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>time-series of local TE values between the series</dd>
</dl>
</li>
</ul>
<a id="computeAverageLocal(int[][],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAverageLocal</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeAverageLocal&#8203;(int[][]&nbsp;states,
                                  int&nbsp;sourceCol,
                                  int&nbsp;destCol)</pre>
<div class="block">Standalone routine to 
 compute local transfer entropy between specific variables in
 a 2D spatiotemporal multivariate time-series.
 Returns the average.
 This method suitable for heterogeneous agents.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable number)</dd>
<dd><code>sourceCol</code> - source variable index in states</dd>
<dd><code>destCol</code> - destination variable index in states</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>average TE for the given pair</dd>
</dl>
</li>
</ul>
<a id="computeAverageLocal(int[][][],int,int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAverageLocal</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeAverageLocal&#8203;(int[][][]&nbsp;states,
                                  int&nbsp;sourceRowIndex,
                                  int&nbsp;sourceColumnIndex,
                                  int&nbsp;destRowIndex,
                                  int&nbsp;destColumnIndex)</pre>
<div class="block">Standalone routine to 
 compute local transfer entropy between specific variables in
 a 3D spatiotemporal multivariate time-series.
 Returns the average.
 This method suitable for heterogeneous agents.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series
  (1st index is time, 2nd index is variable row number,
  3rd is variable column number)</dd>
<dd><code>sourceRowIndex</code> - source variable row index in states</dd>
<dd><code>sourceColumnIndex</code> - source variable column index in states</dd>
<dd><code>destRowIndex</code> - destination variable row index in states</dd>
<dd><code>destColumnIndex</code> - destination variable column index in states</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>average TE for the given pair</dd>
</dl>
</li>
</ul>
<a id="isPeriodicBoundaryConditions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPeriodicBoundaryConditions</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isPeriodicBoundaryConditions()</pre>
<div class="block">Whether we assume periodic boundary conditions in the calls
  for homogeneous variables.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>as above</dd>
</dl>
</li>
</ul>
<a id="setPeriodicBoundaryConditions(boolean)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>setPeriodicBoundaryConditions</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setPeriodicBoundaryConditions&#8203;(boolean&nbsp;periodicBoundaryConditions)</pre>
<div class="block">set whether we assume periodic boundary conditions in the calls
  for homogeneous variables.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>periodicBoundaryConditions</code> - as above</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
