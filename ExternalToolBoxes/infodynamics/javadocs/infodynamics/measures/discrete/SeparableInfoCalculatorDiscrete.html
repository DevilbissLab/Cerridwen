<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.20) on Tue Aug 22 13:03:51 AEST 2023 -->
<title>SeparableInfoCalculatorDiscrete</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-08-22">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../jquery/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="SeparableInfoCalculatorDiscrete";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":9,"i30":9,"i31":9,"i32":9,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":9,"i39":10,"i40":10,"i41":10,"i42":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">infodynamics.measures.discrete</a></div>
<h2 title="Class SeparableInfoCalculatorDiscrete" class="title">Class SeparableInfoCalculatorDiscrete</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="InfoMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">infodynamics.measures.discrete.InfoMeasureCalculatorDiscrete</a></li>
<li>
<ul class="inheritance">
<li><a href="ContextOfPastMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">infodynamics.measures.discrete.ContextOfPastMeasureCalculatorDiscrete</a></li>
<li>
<ul class="inheritance">
<li>infodynamics.measures.discrete.SeparableInfoCalculatorDiscrete</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="SeparableInfoCalculatorDiscreteByAddition.html" title="class in infodynamics.measures.discrete">SeparableInfoCalculatorDiscreteByAddition</a></code></dd>
</dl>
<hr>
<pre>public class <span class="typeNameLabel">SeparableInfoCalculatorDiscrete</span>
extends <a href="ContextOfPastMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">ContextOfPastMeasureCalculatorDiscrete</a></pre>
<div class="block">Implements <b>separable information</b> (see Lizier et al, 2010, below).
 
 Separable information is the sum of active information and apparent transfer entropy from every
  causal information contributor.

 <p>
 Usage of the child classes implementing this interface is intended to follow this paradigm:
 </p>
 <ol>
                <li>Construct the calculator via
                        <a href="#%3Cinit%3E(int,int,int)"><code>SeparableInfoCalculatorDiscrete(int, int, int)</code></a>;</li>
                <li>Initialise the calculator using
                        <a href="#initialise()"><code>initialise()</code></a>;</li>
                <li>Provide the observations/samples for the calculator
        to set up the PDFs, using one or more calls to
                        the set of <a href="#addObservations(int%5B%5D%5B%5D,int%5B%5D)"><code>addObservations(int[][], int[])</code></a> methods, then</li>
                <li>Compute the required quantities, being one or more of:
                        <ul>
                                <li>the average TE: <a href="#computeAverageLocalOfObservations()"><code>computeAverageLocalOfObservations()</code></a>;</li>
                                <li>the local TE values for these samples: <code>#computeLocalOfPreviousObservations()</code></li>
                                <li>local TE values for a specific set of samples: e.g.
                                <a href="#computeLocalFromPreviousObservations(int%5B%5D%5B%5D,int%5B%5D)"><code>computeLocalFromPreviousObservations(int[][], int[])</code></a> etc.</li>
                        </ul>
                </li>
                <li>As an alternative to steps 3 and 4, the user may undertake
                        standalone computation from a single set of observations, via
                e.g.: <a href="#computeLocal(int%5B%5D%5B%5D,int%5B%5D)"><code>computeLocal(int[][], int[])</code></a> or
                <a href="#computeAverageLocal(int%5B%5D%5B%5D,int%5B%5D)"><code>computeAverageLocal(int[][], int[])</code></a>.</li>
                <li>
                Return to step 2 to re-use the calculator on a new data set.
                </li>
        </ol>
 
 <p>The causal information contributors (either their offsets or their absolute column numbers)
  should be supplied in the same order in every method call, otherwise the answer supplied will
  be incorrect.</p>
 
 <p><b>References:</b><br/>
 <ul>
  <li>J. T. Lizier, M. Prokopenko and A. Zomaya,
  <a href=http://dx.doi.org/10.1063/1.3486801">
  "Information modification and particle collisions in distributed computation"</a>
  Chaos 20, 3, 037109 (2010).</li>
 </ul></div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Joseph Lizier (<a href="joseph.lizier at gmail.com">email</a>,
 <a href="http://lizier.me/joseph/">www</a>)</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#avNegativeLocal">avNegativeLocal</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#avPositiveLocal">avPositiveLocal</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#base_power_sources">base_power_sources</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#COLUMN_INDEX">COLUMN_INDEX</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeMultiInfoCoherence">computeMultiInfoCoherence</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FORCE_DIRECT_CALC">FORCE_DIRECT_CALC</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#MAX_CONFIGS_FOR_DIRECT_CALC">MAX_CONFIGS_FOR_DIRECT_CALC</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#meanSqLocals">meanSqLocals</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../continuous/MultiInfoCalculator.html" title="interface in infodynamics.measures.continuous">MultiInfoCalculator</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#miCalc">miCalc</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#numSources">numSources</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#periodicBoundaryConditions">periodicBoundaryConditions</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ROW_INDEX">ROW_INDEX</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int[][][][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sourceNumValueNextPastCount">sourceNumValueNextPastCount</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int[][][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sourceNumValuePastCount">sourceNumValuePastCount</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int[][][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sourcesNextPastCount">sourcesNextPastCount</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="fields.inherited.from.class.infodynamics.measures.discrete.ContextOfPastMeasureCalculatorDiscrete">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;infodynamics.measures.discrete.<a href="ContextOfPastMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">ContextOfPastMeasureCalculatorDiscrete</a></h3>
<code><a href="ContextOfPastMeasureCalculatorDiscrete.html#base_power_k">base_power_k</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#k">k</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#maxShiftedValue">maxShiftedValue</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#nextCount">nextCount</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#nextPastCount">nextPastCount</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#noObservationStorage">noObservationStorage</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#pastCount">pastCount</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="fields.inherited.from.class.infodynamics.measures.discrete.InfoMeasureCalculatorDiscrete">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;infodynamics.measures.discrete.<a href="InfoMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">InfoMeasureCalculatorDiscrete</a></h3>
<code><a href="InfoMeasureCalculatorDiscrete.html#average">average</a>, <a href="InfoMeasureCalculatorDiscrete.html#base">base</a>, <a href="InfoMeasureCalculatorDiscrete.html#debug">debug</a>, <a href="InfoMeasureCalculatorDiscrete.html#log_2">log_2</a>, <a href="InfoMeasureCalculatorDiscrete.html#log_2_base">log_2_base</a>, <a href="InfoMeasureCalculatorDiscrete.html#log_base">log_base</a>, <a href="InfoMeasureCalculatorDiscrete.html#max">max</a>, <a href="InfoMeasureCalculatorDiscrete.html#min">min</a>, <a href="InfoMeasureCalculatorDiscrete.html#observations">observations</a>, <a href="InfoMeasureCalculatorDiscrete.html#power_of_2_base">power_of_2_base</a>, <a href="InfoMeasureCalculatorDiscrete.html#std">std</a></code></li>
</ul>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier</th>
<th class="colSecond" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&nbsp;</code></td>
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(int,int,int)">SeparableInfoCalculatorDiscrete</a></span>&#8203;(int&nbsp;base,
                               int&nbsp;history,
                               int&nbsp;numInfoContributors)</code></th>
<td class="colLast">
<div class="block">Construct an instance</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected </code></td>
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(int,int,int,boolean)">SeparableInfoCalculatorDiscrete</a></span>&#8203;(int&nbsp;base,
                               int&nbsp;history,
                               int&nbsp;numInfoContributors,
                               boolean&nbsp;dontCreateObsStorage)</code></th>
<td class="colLast">
<div class="block">Private method to implement the public constructor</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addObservations(int%5B%5D%5B%5D%5B%5D,int%5B%5D%5B%5D)">addObservations</a></span>&#8203;(int[][][]&nbsp;states,
               int[][]&nbsp;offsetOfDestFromSources)</code></th>
<td class="colLast">
<div class="block">Add observations in to our estimates of the pdfs.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addObservations(int%5B%5D%5B%5D%5B%5D,int,int,int%5B%5D%5B%5D)">addObservations</a></span>&#8203;(int[][][]&nbsp;states,
               int&nbsp;destAgentRow,
               int&nbsp;destAgentColumn,
               int[][]&nbsp;sourcesAbsolute)</code></th>
<td class="colLast">
<div class="block">Add observations for a single destination pair of the 
 multivariate time series
  to our estimates of the pdfs.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addObservations(int%5B%5D%5B%5D,int%5B%5D)">addObservations</a></span>&#8203;(int[][]&nbsp;states,
               int[]&nbsp;offsetOfDestFromSources)</code></th>
<td class="colLast">
<div class="block">Add observations in to our estimates of the pdfs.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addObservations(int%5B%5D%5B%5D,int,int%5B%5D)">addObservations</a></span>&#8203;(int[][]&nbsp;states,
               int&nbsp;destCol,
               int[]&nbsp;sourcesAbsolute)</code></th>
<td class="colLast">
<div class="block">Add observations for a single destination of the multi-agent system
  to our estimates of the pdfs.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#canComputeMultiInfoCoherenceFromAverageOfObservations()">canComputeMultiInfoCoherenceFromAverageOfObservations</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>int[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cleanAbsoluteSources(int%5B%5D%5B%5D,int,int)">cleanAbsoluteSources</a></span>&#8203;(int[][]&nbsp;sources,
                    int&nbsp;destAgentRow,
                    int&nbsp;destAgentColumn)</code></th>
<td class="colLast">
<div class="block">Returns the information contributors to the dest which
 are not equal to the node itself (offset 0).</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cleanAbsoluteSources(int%5B%5D,int)">cleanAbsoluteSources</a></span>&#8203;(int[]&nbsp;sources,
                    int&nbsp;dest)</code></th>
<td class="colLast">
<div class="block">Returns the information contributors to the dest which
 are not equal to the node itself (offset 0).</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cleanOffsetOfDestFromSources(int%5B%5D)">cleanOffsetOfDestFromSources</a></span>&#8203;(int[]&nbsp;sourcesOffsets)</code></th>
<td class="colLast">
<div class="block">Returns the information contributors to this node which
 are not equal to the node itself (offset 0).</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>int[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cleanOffsetOfDestFromSources(int%5B%5D%5B%5D)">cleanOffsetOfDestFromSources</a></span>&#8203;(int[][]&nbsp;sourcesOffsets)</code></th>
<td class="colLast">
<div class="block">Returns the information contributors to this node which
 are not equal to the node itself (offset (0,0)).</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearComputeMultiInfoCoherence()">clearComputeMultiInfoCoherence</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeAverageLocal(int%5B%5D%5B%5D%5B%5D,int%5B%5D%5B%5D)">computeAverageLocal</a></span>&#8203;(int[][][]&nbsp;states,
                   int[][]&nbsp;sourceOffsets)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute average separable information across a 3D multivariate time series
  of the states of homogeneous agents.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeAverageLocal(int%5B%5D%5B%5D%5B%5D,int,int,int%5B%5D%5B%5D)">computeAverageLocal</a></span>&#8203;(int[][][]&nbsp;states,
                   int&nbsp;destAgentRow,
                   int&nbsp;destAgentColumn,
                   int[][]&nbsp;sourcesAbsolute)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute average separable information for a specific destination
 in a 3D multivariate time series
  of the states.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeAverageLocal(int%5B%5D%5B%5D,int%5B%5D)">computeAverageLocal</a></span>&#8203;(int[][]&nbsp;states,
                   int[]&nbsp;sourceOffsets)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute average separable information across a 2D multivariate time series
  of the states of homogeneous agents.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeAverageLocal(int%5B%5D%5B%5D,int,int%5B%5D)">computeAverageLocal</a></span>&#8203;(int[][]&nbsp;states,
                   int&nbsp;destCol,
                   int[]&nbsp;sourcesAbsolute)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute average separable information for a specific destination
 in a 2D multivariate time series
  of the states.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeAverageLocalOfObservations()">computeAverageLocalOfObservations</a></span>()</code></th>
<td class="colLast">
<div class="block">Compute the average value of the measure
 from the previously-supplied samples.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeAverageLocalOfObservations(int%5B%5D,int)">computeAverageLocalOfObservations</a></span>&#8203;(int[]&nbsp;sourceValues,
                                 int&nbsp;indexToModify)</code></th>
<td class="colLast">
<div class="block">Private utility function.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>double[][][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocal(int%5B%5D%5B%5D%5B%5D,int%5B%5D%5B%5D)">computeLocal</a></span>&#8203;(int[][][]&nbsp;states,
            int[][]&nbsp;offsetOfDestFromSources)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute local separable info across a 3D multivariate time series
  of the states of homogeneous agents.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocal(int%5B%5D%5B%5D%5B%5D,int,int,int%5B%5D%5B%5D)">computeLocal</a></span>&#8203;(int[][][]&nbsp;states,
            int&nbsp;destAgentRow,
            int&nbsp;destAgentColumn,
            int[][]&nbsp;sourcesAbsolute)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute local separable information for a specific destination
 in a 3D multivariate time series
  of the states.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocal(int%5B%5D%5B%5D,int%5B%5D)">computeLocal</a></span>&#8203;(int[][]&nbsp;states,
            int[]&nbsp;offsetOfDestFromSources)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute local separable info across a 2D multivariate time series
  of the states of homogeneous agents
 Return a 2D spatiotemporal multivariate time series of local values.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocal(int%5B%5D%5B%5D,int,int%5B%5D)">computeLocal</a></span>&#8203;(int[][]&nbsp;states,
            int&nbsp;destCol,
            int[]&nbsp;sourcesAbsolute)</code></th>
<td class="colLast">
<div class="block">Standalone routine to 
 compute local separable information for a specific destination
 in a 2D multivariate time series
  of the states.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>double[][][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocalFromPreviousObservations(int%5B%5D%5B%5D%5B%5D,int%5B%5D%5B%5D)">computeLocalFromPreviousObservations</a></span>&#8203;(int[][][]&nbsp;states,
                                    int[][]&nbsp;offsetOfDestFromSources)</code></th>
<td class="colLast">
<div class="block">Computes local separable information for the given
  states, using pdfs built up from observations previously
  sent in via the addObservations method.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocalFromPreviousObservations(int%5B%5D%5B%5D%5B%5D,int,int,int%5B%5D%5B%5D)">computeLocalFromPreviousObservations</a></span>&#8203;(int[][][]&nbsp;states,
                                    int&nbsp;destAgentRow,
                                    int&nbsp;destAgentColumn,
                                    int[][]&nbsp;sourcesAbsolute)</code></th>
<td class="colLast">
<div class="block">Computes local separable information for the given
  destination variable in a multivariate time series,
  using pdfs built up from observations previously
  sent in via the addObservations method.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocalFromPreviousObservations(int%5B%5D%5B%5D,int%5B%5D)">computeLocalFromPreviousObservations</a></span>&#8203;(int[][]&nbsp;states,
                                    int[]&nbsp;offsetOfDestFromSources)</code></th>
<td class="colLast">
<div class="block">Computes local separable information for the given
  states, using pdfs built up from observations previously
  sent in via the addObservations method.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeLocalFromPreviousObservations(int%5B%5D%5B%5D,int,int%5B%5D)">computeLocalFromPreviousObservations</a></span>&#8203;(int[][]&nbsp;states,
                                    int&nbsp;destCol,
                                    int[]&nbsp;sourcesAbsolute)</code></th>
<td class="colLast">
<div class="block">Computes local separable information for the given
  destination in the multivariate time series,
  using pdfs built up from observations previously
  sent in via the addObservations method.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#computeMultiInfoCoherence()">computeMultiInfoCoherence</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#confirmEnoughAbsoluteSources(int%5B%5D%5B%5D,int,int)">confirmEnoughAbsoluteSources</a></span>&#8203;(int[][]&nbsp;sourcesAbsolute,
                            int&nbsp;destAgentRow,
                            int&nbsp;destAgentColumn)</code></th>
<td class="colLast">
<div class="block">Check that the supplied array of absolutes as sources
  is long enough compared to our expectation</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#confirmEnoughAbsoluteSources(int%5B%5D,int)">confirmEnoughAbsoluteSources</a></span>&#8203;(int[]&nbsp;sourcesAbsolute,
                            int&nbsp;dest)</code></th>
<td class="colLast">
<div class="block">Check that the supplied array of absolutes as sources
  is long enough compared to our expectation</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#confirmEnoughOffsetSources(int%5B%5D)">confirmEnoughOffsetSources</a></span>&#8203;(int[]&nbsp;sourcesOffsets)</code></th>
<td class="colLast">
<div class="block">Check that the supplied array of offsets as sources
  is long enough compared to our expectation</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#confirmEnoughOffsetSources(int%5B%5D%5B%5D)">confirmEnoughOffsetSources</a></span>&#8203;(int[][]&nbsp;sourcesOffsets)</code></th>
<td class="colLast">
<div class="block">Check that the supplied array of offsets as sources
  is long enough compared to our expectation</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countOfAbsoluteSources(int%5B%5D%5B%5D,int,int)">countOfAbsoluteSources</a></span>&#8203;(int[][]&nbsp;sources,
                      int&nbsp;destAgentRow,
                      int&nbsp;destAgentColumn)</code></th>
<td class="colLast">
<div class="block">Counts the information contributors to the dest which
 are not equal to the node itself</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countOfAbsoluteSources(int%5B%5D,int)">countOfAbsoluteSources</a></span>&#8203;(int[]&nbsp;sources,
                      int&nbsp;dest)</code></th>
<td class="colLast">
<div class="block">Counts the information contributors to the dest which
 are not equal to the node itself</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countOfOffsetSources(int%5B%5D)">countOfOffsetSources</a></span>&#8203;(int[]&nbsp;sourcesOffsets)</code></th>
<td class="colLast">
<div class="block">Counts the information contributors to this node which
 are not equal to the node itself (offset 0)</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countOfOffsetSources(int%5B%5D%5B%5D)">countOfOffsetSources</a></span>&#8203;(int[][]&nbsp;sourcesOffsets)</code></th>
<td class="colLast">
<div class="block">Counts the information contributors to this node which
 are not equal to the node itself (offset (0,0))</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLastAverageNegative()">getLastAverageNegative</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the average of the negative components from the
  last computation.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getLastAveragePositive()">getLastAveragePositive</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the average of the positive components from the
  last computation.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initialise()">initialise</a></span>()</code></th>
<td class="colLast">
<div class="block">Initialise the calculator for re-use with new observations.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isComputeMultiInfoCoherence()">isComputeMultiInfoCoherence</a></span>()</code></th>
<td class="colLast">
<div class="block">Whether the calculator should gather observations to
  compute a multi-info between the local TEs and
  AIS values.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isPeriodicBoundaryConditions()">isPeriodicBoundaryConditions</a></span>()</code></th>
<td class="colLast">
<div class="block">Whether we use periodic boundary conditions when considering
 spatiotemporal data for homogeneous variables</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static <a href="SeparableInfoCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">SeparableInfoCalculatorDiscrete</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#newInstance(int,int,int)">newInstance</a></span>&#8203;(int&nbsp;base,
           int&nbsp;history,
           int&nbsp;numInfoContributors)</code></th>
<td class="colLast">
<div class="block">User to create new instances through this factory method.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#resetMultiInfoCoherenceCalculator()">resetMultiInfoCoherenceCalculator</a></span>()</code></th>
<td class="colLast">
<div class="block">Allows reclaiming of some vital memory</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setComputeMultiInfoCoherence(java.lang.String,java.util.Properties)">setComputeMultiInfoCoherence</a></span>&#8203;(java.lang.String&nbsp;miCoherenceCalculatorClass,
                            java.util.Properties&nbsp;props)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setDebug(boolean)">setDebug</a></span>&#8203;(boolean&nbsp;debug)</code></th>
<td class="colLast">
<div class="block">Set or clear debug mode for extra debug printing to stdout</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setPeriodicBoundaryConditions(boolean)">setPeriodicBoundaryConditions</a></span>&#8203;(boolean&nbsp;periodicBoundaryConditions)</code></th>
<td class="colLast">
<div class="block">Set whether to use periodic boundary conditions</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.infodynamics.measures.discrete.ContextOfPastMeasureCalculatorDiscrete">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;infodynamics.measures.discrete.<a href="ContextOfPastMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">ContextOfPastMeasureCalculatorDiscrete</a></h3>
<code><a href="ContextOfPastMeasureCalculatorDiscrete.html#computePastValue(int%5B%5D%5B%5D%5B%5D,int,int,int)">computePastValue</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#computePastValue(int%5B%5D%5B%5D,int,int)">computePastValue</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#computePastValue(int%5B%5D,int)">computePastValue</a>, <a href="ContextOfPastMeasureCalculatorDiscrete.html#initialise(int,int)">initialise</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.infodynamics.measures.discrete.InfoMeasureCalculatorDiscrete">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;infodynamics.measures.discrete.<a href="InfoMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">InfoMeasureCalculatorDiscrete</a></h3>
<code><a href="InfoMeasureCalculatorDiscrete.html#getLastAverage()">getLastAverage</a>, <a href="InfoMeasureCalculatorDiscrete.html#getLastMax()">getLastMax</a>, <a href="InfoMeasureCalculatorDiscrete.html#getLastMin()">getLastMin</a>, <a href="InfoMeasureCalculatorDiscrete.html#getLastStd()">getLastStd</a>, <a href="InfoMeasureCalculatorDiscrete.html#getNumObservations()">getNumObservations</a>, <a href="InfoMeasureCalculatorDiscrete.html#initialise(int)">initialise</a>, <a href="InfoMeasureCalculatorDiscrete.html#isPowerOf2(int)">isPowerOf2</a>, <a href="InfoMeasureCalculatorDiscrete.html#resetBase(int)">resetBase</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="numSources">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>numSources</h4>
<pre>protected&nbsp;int numSources</pre>
</li>
</ul>
<a id="base_power_sources">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>base_power_sources</h4>
<pre>protected&nbsp;int base_power_sources</pre>
</li>
</ul>
<a id="sourceNumValueNextPastCount">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sourceNumValueNextPastCount</h4>
<pre>protected&nbsp;int[][][][] sourceNumValueNextPastCount</pre>
</li>
</ul>
<a id="sourcesNextPastCount">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sourcesNextPastCount</h4>
<pre>protected&nbsp;int[][][] sourcesNextPastCount</pre>
</li>
</ul>
<a id="sourceNumValuePastCount">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sourceNumValuePastCount</h4>
<pre>protected&nbsp;int[][][] sourceNumValuePastCount</pre>
</li>
</ul>
<a id="avPositiveLocal">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>avPositiveLocal</h4>
<pre>protected&nbsp;double avPositiveLocal</pre>
</li>
</ul>
<a id="avNegativeLocal">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>avNegativeLocal</h4>
<pre>protected&nbsp;double avNegativeLocal</pre>
</li>
</ul>
<a id="meanSqLocals">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>meanSqLocals</h4>
<pre>protected&nbsp;double meanSqLocals</pre>
</li>
</ul>
<a id="periodicBoundaryConditions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>periodicBoundaryConditions</h4>
<pre>protected&nbsp;boolean periodicBoundaryConditions</pre>
</li>
</ul>
<a id="computeMultiInfoCoherence">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeMultiInfoCoherence</h4>
<pre>protected&nbsp;boolean computeMultiInfoCoherence</pre>
</li>
</ul>
<a id="miCalc">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>miCalc</h4>
<pre>protected&nbsp;<a href="../continuous/MultiInfoCalculator.html" title="interface in infodynamics.measures.continuous">MultiInfoCalculator</a> miCalc</pre>
</li>
</ul>
<a id="ROW_INDEX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ROW_INDEX</h4>
<pre>public static final&nbsp;int ROW_INDEX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#infodynamics.measures.discrete.SeparableInfoCalculatorDiscrete.ROW_INDEX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="COLUMN_INDEX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COLUMN_INDEX</h4>
<pre>public static final&nbsp;int COLUMN_INDEX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#infodynamics.measures.discrete.SeparableInfoCalculatorDiscrete.COLUMN_INDEX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="MAX_CONFIGS_FOR_DIRECT_CALC">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MAX_CONFIGS_FOR_DIRECT_CALC</h4>
<pre>public static&nbsp;int MAX_CONFIGS_FOR_DIRECT_CALC</pre>
</li>
</ul>
<a id="FORCE_DIRECT_CALC">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>FORCE_DIRECT_CALC</h4>
<pre>public static&nbsp;boolean FORCE_DIRECT_CALC</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SeparableInfoCalculatorDiscrete</h4>
<pre>public&nbsp;SeparableInfoCalculatorDiscrete&#8203;(int&nbsp;base,
                                       int&nbsp;history,
                                       int&nbsp;numInfoContributors)</pre>
<div class="block">Construct an instance</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>base</code> - number of symbols for each variable.
        E.g. binary variables are in base-2.</dd>
<dd><code>history</code> - embedded history length of the destination to condition on -
        this is k in Schreiber's notation.</dd>
<dd><code>numOtherInfoContributors</code> - number of information contributors
   (other than the past of the destination
   or the source) to condition on.</dd>
</dl>
</li>
</ul>
<a id="&lt;init&gt;(int,int,int,boolean)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>SeparableInfoCalculatorDiscrete</h4>
<pre>protected&nbsp;SeparableInfoCalculatorDiscrete&#8203;(int&nbsp;base,
                                          int&nbsp;history,
                                          int&nbsp;numInfoContributors,
                                          boolean&nbsp;dontCreateObsStorage)</pre>
<div class="block">Private method to implement the public constructor</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>base</code> - number of symbols for each variable.
        E.g. binary variables are in base-2.</dd>
<dd><code>history</code> - embedded history length of the destination to condition on -
        this is k in Schreiber's notation.</dd>
<dd><code>numOtherInfoContributors</code> - number of information contributors
   (other than the past of the destination
   or the source) to condition on.</dd>
<dd><code>dontCreateObsStorage</code> - indicates that storage for
  observations should not be created.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="newInstance(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newInstance</h4>
<pre class="methodSignature">public static&nbsp;<a href="SeparableInfoCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">SeparableInfoCalculatorDiscrete</a>&nbsp;newInstance&#8203;(int&nbsp;base,
                                                          int&nbsp;history,
                                                          int&nbsp;numInfoContributors)</pre>
<div class="block">User to create new instances through this factory method.
 This allows us to return an efficient calculator for
 particular situations without the user needing to have 
 knowledge of this.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>base</code> - </dd>
<dd><code>history</code> - </dd>
<dd><code>numInfoContributors</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="initialise()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initialise</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;initialise()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="InfoMeasureCalculatorDiscrete.html#initialise()">InfoMeasureCalculatorDiscrete</a></code></span></div>
<div class="block">Initialise the calculator for re-use with new observations.
 (Child classes should clear the existing PDFs)</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="ContextOfPastMeasureCalculatorDiscrete.html#initialise()">initialise</a></code>&nbsp;in class&nbsp;<code><a href="ContextOfPastMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">ContextOfPastMeasureCalculatorDiscrete</a></code></dd>
</dl>
</li>
</ul>
<a id="addObservations(int[][],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addObservations</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addObservations&#8203;(int[][]&nbsp;states,
                            int[]&nbsp;offsetOfDestFromSources)</pre>
<div class="block">Add observations in to our estimates of the pdfs.
 This call suitable only for homogeneous agents, as all
  agents will contribute to single pdfs, and all are assumed
  to have other info contributors at same offsets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series, 1st index is time, 2nd index is agent number</dd>
<dd><code>offsetOfDestFromSources</code> - offsets of the destination *from* causal information contributors.
                  (i.e. an offset of 1 means the destination is one index larger, or one to the right,
                        than the source). 
        sourcesOffsets is permitted to include 0, it will be ignored.</dd>
</dl>
</li>
</ul>
<a id="addObservations(int[][][],int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addObservations</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addObservations&#8203;(int[][][]&nbsp;states,
                            int[][]&nbsp;offsetOfDestFromSources)</pre>
<div class="block">Add observations in to our estimates of the pdfs.
 This call suitable only for homogeneous agents, as all
  agents will contribute to single pdfs, and all are assumed
  to have other info contributors at same offsets.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series 1st index is time, 2nd and 3rd index give the 2D agent number</dd>
<dd><code>offsetOfDestFromSources</code> - 2D offsets of the destination *from* causal information contributors.
                  (i.e. an offset of 1 means the destination is one index larger, or one to the right,
                        than the source). 
        offsetOfDestFromSources is permitted to include 0, it will be ignored.</dd>
</dl>
</li>
</ul>
<a id="addObservations(int[][],int,int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addObservations</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addObservations&#8203;(int[][]&nbsp;states,
                            int&nbsp;destCol,
                            int[]&nbsp;sourcesAbsolute)</pre>
<div class="block">Add observations for a single destination of the multi-agent system
  to our estimates of the pdfs.
 This call should be made as opposed to addObservations(int states[][])
  for computing active info for heterogeneous agents.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series, 1st index is time, 2nd index is agent number</dd>
<dd><code>destCol</code> - the destination index</dd>
<dd><code>sourcesAbsolute</code> - array of the source indices</dd>
</dl>
</li>
</ul>
<a id="addObservations(int[][][],int,int,int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addObservations</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;addObservations&#8203;(int[][][]&nbsp;states,
                            int&nbsp;destAgentRow,
                            int&nbsp;destAgentColumn,
                            int[][]&nbsp;sourcesAbsolute)</pre>
<div class="block">Add observations for a single destination pair of the 
 multivariate time series
  to our estimates of the pdfs.
 This call should be made as opposed to addObservations(int states[][])
  for computing active info for heterogeneous agents.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series: 1st index is time, 2nd and 3rd index give the 2D agent number</dd>
<dd><code>destAgentRow</code> - the destination index</dd>
<dd><code>destAgentColumn</code> - the destination index</dd>
<dd><code>sourcesAbsolute</code> - array of the source indices</dd>
</dl>
</li>
</ul>
<a id="computeAverageLocalOfObservations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAverageLocalOfObservations</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeAverageLocalOfObservations()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="InfoMeasureCalculatorDiscrete.html#computeAverageLocalOfObservations()">InfoMeasureCalculatorDiscrete</a></code></span></div>
<div class="block">Compute the average value of the measure
 from the previously-supplied samples.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="InfoMeasureCalculatorDiscrete.html#computeAverageLocalOfObservations()">computeAverageLocalOfObservations</a></code>&nbsp;in class&nbsp;<code><a href="InfoMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">InfoMeasureCalculatorDiscrete</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the estimate of the measure</dd>
</dl>
</li>
</ul>
<a id="computeAverageLocalOfObservations(int[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAverageLocalOfObservations</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;computeAverageLocalOfObservations&#8203;(int[]&nbsp;sourceValues,
                                                 int&nbsp;indexToModify)</pre>
<div class="block">Private utility function.
 
 <p>Updates the average, max, min and meanSq of locals for the separable information
  for the given source values in sourceValues up to the index indexToModify over
  all possible source values after the index indexToModify onwards. Uses recursion
  on increasing indexToModify.
 Designed to be called with indexToModify == 0 to compute average over all states.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourceValues</code> - </dd>
<dd><code>indexToModify</code> - </dd>
</dl>
</li>
</ul>
<a id="computeLocalFromPreviousObservations(int[][],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocalFromPreviousObservations</h4>
<pre class="methodSignature">public&nbsp;double[][]&nbsp;computeLocalFromPreviousObservations&#8203;(int[][]&nbsp;states,
                                                       int[]&nbsp;offsetOfDestFromSources)</pre>
<div class="block">Computes local separable information for the given
  states, using pdfs built up from observations previously
  sent in via the addObservations method.
 This method to be used for homogeneous agents only
  since it assumes the source offsets are the same
  for all destinations (and all are added to the PDFs)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series 1st index is time, 2nd is agent index</dd>
<dd><code>offsetOfDestFromSources</code> - offsets of the destination *from* causal information contributors.
                  (i.e. an offset of 1 means the destination is one index larger, or one to the right,
                        than the source). 
        sourcesOffsets is permitted to include 0, it will be ignored.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multivariate time series of local separable information,
  indexed as per states.</dd>
</dl>
</li>
</ul>
<a id="computeLocalFromPreviousObservations(int[][][],int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocalFromPreviousObservations</h4>
<pre class="methodSignature">public&nbsp;double[][][]&nbsp;computeLocalFromPreviousObservations&#8203;(int[][][]&nbsp;states,
                                                         int[][]&nbsp;offsetOfDestFromSources)</pre>
<div class="block">Computes local separable information for the given
  states, using pdfs built up from observations previously
  sent in via the addObservations method.
 This method to be used for homogeneous agents only
  since it assumes offsets are same for all destinations
  and includes them all in the calculation</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series 1st index is time, 2nd and 3rd index give the 2D agent number</dd>
<dd><code>offsetOfDestFromSources</code> - offsets of the destination *from* causal information contributors.
                  (i.e. an offset of 1 means the destination is one index larger, or one to the right,
                        than the source). 
        sourcesOffsets is permitted to include 0, it will be ignored.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multivariate time series of local separable information
  values, indexed as per states.</dd>
</dl>
</li>
</ul>
<a id="computeLocalFromPreviousObservations(int[][],int,int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocalFromPreviousObservations</h4>
<pre class="methodSignature">public&nbsp;double[]&nbsp;computeLocalFromPreviousObservations&#8203;(int[][]&nbsp;states,
                                                     int&nbsp;destCol,
                                                     int[]&nbsp;sourcesAbsolute)</pre>
<div class="block">Computes local separable information for the given
  destination in the multivariate time series,
  using pdfs built up from observations previously
  sent in via the addObservations method.
 This method is suitable for heterogeneous agents</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series 1st index is time, 2nd index is agent number</dd>
<dd><code>destCol</code> - index for the destination agent</dd>
<dd><code>sourcesAbsolute</code> - indices for the source agents</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multivariate time series of local separable information
  values for the given destination variable</dd>
</dl>
</li>
</ul>
<a id="computeLocalFromPreviousObservations(int[][][],int,int,int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocalFromPreviousObservations</h4>
<pre class="methodSignature">public&nbsp;double[]&nbsp;computeLocalFromPreviousObservations&#8203;(int[][][]&nbsp;states,
                                                     int&nbsp;destAgentRow,
                                                     int&nbsp;destAgentColumn,
                                                     int[][]&nbsp;sourcesAbsolute)</pre>
<div class="block">Computes local separable information for the given
  destination variable in a multivariate time series,
  using pdfs built up from observations previously
  sent in via the addObservations method.
 This method is suitable for heterogeneous agents</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series: 1st index is time,
        2nd and 3rd index give the 2D agent number</dd>
<dd><code>destAgentRow</code> - the destination index</dd>
<dd><code>destAgentColumn</code> - the destination index</dd>
<dd><code>sourcesAbsolute</code> - array of the source indices</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multivariate time series of local separable information
  values for the given destination</dd>
</dl>
</li>
</ul>
<a id="computeLocal(int[][],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocal</h4>
<pre class="methodSignature">public&nbsp;double[][]&nbsp;computeLocal&#8203;(int[][]&nbsp;states,
                               int[]&nbsp;offsetOfDestFromSources)</pre>
<div class="block">Standalone routine to 
 compute local separable info across a 2D multivariate time series
  of the states of homogeneous agents
 Return a 2D spatiotemporal multivariate time series of local values.
 First history rows are zeros.
 This method to be called for homogeneous agents only
 since it assumes all destinations have the same source offsets
 and includes them all in the calculation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series: first index is time,
  second is variable index.</dd>
<dd><code>offsetOfDestFromSources</code> - offsets of the destination *from* causal information contributors.
                  (i.e. an offset of 1 means the destination is one index larger, or one to the right,
                        than the source). 
        sourcesOffsets is permitted to include 0, it will be ignored.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multivariate time series of local separable information,
  indexed as per states.</dd>
</dl>
</li>
</ul>
<a id="computeLocal(int[][][],int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocal</h4>
<pre class="methodSignature">public&nbsp;double[][][]&nbsp;computeLocal&#8203;(int[][][]&nbsp;states,
                                 int[][]&nbsp;offsetOfDestFromSources)</pre>
<div class="block">Standalone routine to 
 compute local separable info across a 3D multivariate time series
  of the states of homogeneous agents.
 Return a 3D spatiotemporal array of local values.
 First history rows are zeros.
 This method to be called for homogeneous agents only
 since it assumes all destinations have the same source offsets
 and includes them all in the calculation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series: 1st index is time, 2nd and 3rd are agent indices</dd>
<dd><code>offsetOfDestFromSources</code> - offsets of the destination *from* causal information contributors.
                  (i.e. an offset of 1 means the destination is one index larger, or one to the right,
                        than the source). 
        sourcesOffsets is permitted to include 0, it will be ignored.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>multivariate time series of local separable information,
  indexed as per states.</dd>
</dl>
</li>
</ul>
<a id="computeAverageLocal(int[][],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAverageLocal</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeAverageLocal&#8203;(int[][]&nbsp;states,
                                  int[]&nbsp;sourceOffsets)</pre>
<div class="block">Standalone routine to 
 compute average separable information across a 2D multivariate time series
  of the states of homogeneous agents.
 Return the average.
 This method to be called for homogeneous agents only
 since it assumes all destinations have the same source offsets
 and includes them all in the calculation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series: first index is time,
  second is variable number</dd>
<dd><code>sourceOffsets</code> - column offsets for causal info contributors
  from each destination</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>average separable information for these
  observations.</dd>
</dl>
</li>
</ul>
<a id="computeAverageLocal(int[][][],int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAverageLocal</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeAverageLocal&#8203;(int[][][]&nbsp;states,
                                  int[][]&nbsp;sourceOffsets)</pre>
<div class="block">Standalone routine to 
 compute average separable information across a 3D multivariate time series
  of the states of homogeneous agents.
 Return the average separable info.
 This method to be called for homogeneous agents only
 since it assumes all destinations have the same source offsets
 and includes them all in the calculation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series: 1st index is time, 2nd and 3rd are agent indices</dd>
<dd><code>sourceOffsets</code> - agent offsets for causal info contributors. 1st index points to 
  an array of two elements for the row and column offsets.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>average separable information for these
  observations.</dd>
</dl>
</li>
</ul>
<a id="computeLocal(int[][],int,int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocal</h4>
<pre class="methodSignature">public&nbsp;double[]&nbsp;computeLocal&#8203;(int[][]&nbsp;states,
                             int&nbsp;destCol,
                             int[]&nbsp;sourcesAbsolute)</pre>
<div class="block">Standalone routine to 
 compute local separable information for a specific destination
 in a 2D multivariate time series
  of the states.
 Return a 2D spatiotemporal array of local values.
 First history rows are zeros.
 This method suitable for heterogeneous agents</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series: first index is time,
  second is variable number</dd>
<dd><code>destCol</code> - column index for the destination agent to consider</dd>
<dd><code>sourcesAbsolute</code> - column indices for causal info contributors
  to this destination</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>time series of local separable information</dd>
</dl>
</li>
</ul>
<a id="computeLocal(int[][][],int,int,int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeLocal</h4>
<pre class="methodSignature">public&nbsp;double[]&nbsp;computeLocal&#8203;(int[][][]&nbsp;states,
                             int&nbsp;destAgentRow,
                             int&nbsp;destAgentColumn,
                             int[][]&nbsp;sourcesAbsolute)</pre>
<div class="block">Standalone routine to 
 compute local separable information for a specific destination
 in a 3D multivariate time series
  of the states.
 First history rows are zeros.
 This method suitable for heterogeneous agents.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series: 1st index is time, 2nd and 3rd are agent indices</dd>
<dd><code>destAgentRow</code> - row index for the destination agent</dd>
<dd><code>destAgnetColumn</code> - column index for the destination agent</dd>
<dd><code>sourcesAbsolute</code> - absolute indices for causal info contributors to this destination</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>time series of local separable information</dd>
</dl>
</li>
</ul>
<a id="computeAverageLocal(int[][],int,int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAverageLocal</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeAverageLocal&#8203;(int[][]&nbsp;states,
                                  int&nbsp;destCol,
                                  int[]&nbsp;sourcesAbsolute)</pre>
<div class="block">Standalone routine to 
 compute average separable information for a specific destination
 in a 2D multivariate time series
  of the states.
 Returns the average.
 This method suitable for heterogeneous agents</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series: first index is time,
  second is variable number</dd>
<dd><code>destCol</code> - column index for the destination agent</dd>
<dd><code>sourcesAbsolute</code> - column indices for causal info contributors</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>average separable information for this destination</dd>
</dl>
</li>
</ul>
<a id="computeAverageLocal(int[][][],int,int,int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeAverageLocal</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeAverageLocal&#8203;(int[][][]&nbsp;states,
                                  int&nbsp;destAgentRow,
                                  int&nbsp;destAgentColumn,
                                  int[][]&nbsp;sourcesAbsolute)</pre>
<div class="block">Standalone routine to 
 compute average separable information for a specific destination
 in a 3D multivariate time series
  of the states.
 Returns the average.
 This method suitable for heterogeneous agents</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>states</code> - multivariate time series: 1st index is time, 2nd and 3rd are agent indices</dd>
<dd><code>destAgentRow</code> - row index for the destination agent</dd>
<dd><code>destAgnetColumn</code> - column index for the destination agent</dd>
<dd><code>sourcesAbsolute</code> - absolute indices for causal info contributors to this destination</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>average separable information for this destination</dd>
</dl>
</li>
</ul>
<a id="getLastAveragePositive()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLastAveragePositive</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getLastAveragePositive()</pre>
<div class="block">Returns the average of the positive components from the
  last computation.
 The average is taken over all components, whether positive
  or negative, such that:
  getLastAveragePositive() + getLastAverageNegative()
   == getLastAverage()</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="getLastAverageNegative()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLastAverageNegative</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;getLastAverageNegative()</pre>
<div class="block">Returns the average of the negative components from the
  last computation.
 The average is taken over all components, whether positive
  or negative, such that:
  getLastAveragePositive() + getLastAverageNegative()
   == getLastAverage()</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="countOfOffsetSources(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countOfOffsetSources</h4>
<pre class="methodSignature">public static&nbsp;int&nbsp;countOfOffsetSources&#8203;(int[]&nbsp;sourcesOffsets)</pre>
<div class="block">Counts the information contributors to this node which
 are not equal to the node itself (offset 0)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourcesOffsets</code> - information contributors</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of sourcesOffsets with any 0 entries removed from the array</dd>
</dl>
</li>
</ul>
<a id="countOfOffsetSources(int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countOfOffsetSources</h4>
<pre class="methodSignature">public static&nbsp;int&nbsp;countOfOffsetSources&#8203;(int[][]&nbsp;sourcesOffsets)</pre>
<div class="block">Counts the information contributors to this node which
 are not equal to the node itself (offset (0,0))</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourcesOffsets</code> - information contributors</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of sourcesOffsets with any (0,0) entries removed from the 2D array</dd>
</dl>
</li>
</ul>
<a id="countOfAbsoluteSources(int[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countOfAbsoluteSources</h4>
<pre class="methodSignature">public static&nbsp;int&nbsp;countOfAbsoluteSources&#8203;(int[]&nbsp;sources,
                                         int&nbsp;dest)</pre>
<div class="block">Counts the information contributors to the dest which
 are not equal to the node itself</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - array of source indices</dd>
<dd><code>dest</code> - index of dest</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of sources with any entries equal to dest removed.</dd>
</dl>
</li>
</ul>
<a id="countOfAbsoluteSources(int[][],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countOfAbsoluteSources</h4>
<pre class="methodSignature">public static&nbsp;int&nbsp;countOfAbsoluteSources&#8203;(int[][]&nbsp;sources,
                                         int&nbsp;destAgentRow,
                                         int&nbsp;destAgentColumn)</pre>
<div class="block">Counts the information contributors to the dest which
 are not equal to the node itself</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - array of arrays of row and column indices</dd>
<dd><code>destAgentRow</code> - row of dest variable</dd>
<dd><code>destAgentColumn</code> - column of dest variable</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of entries in sources not equal to the dest indices</dd>
</dl>
</li>
</ul>
<a id="confirmEnoughOffsetSources(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>confirmEnoughOffsetSources</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;confirmEnoughOffsetSources&#8203;(int[]&nbsp;sourcesOffsets)</pre>
<div class="block">Check that the supplied array of offsets as sources
  is long enough compared to our expectation</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourcesOffsets</code> - array of source offsets</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether it is as long as expected</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if it is not</dd>
</dl>
</li>
</ul>
<a id="confirmEnoughOffsetSources(int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>confirmEnoughOffsetSources</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;confirmEnoughOffsetSources&#8203;(int[][]&nbsp;sourcesOffsets)</pre>
<div class="block">Check that the supplied array of offsets as sources
  is long enough compared to our expectation</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourcesOffsets</code> - array of 2D source offsets</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether it is as long as expected</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if it is not</dd>
</dl>
</li>
</ul>
<a id="confirmEnoughAbsoluteSources(int[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>confirmEnoughAbsoluteSources</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;confirmEnoughAbsoluteSources&#8203;(int[]&nbsp;sourcesAbsolute,
                                            int&nbsp;dest)</pre>
<div class="block">Check that the supplied array of absolutes as sources
  is long enough compared to our expectation</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourcesAbsolute</code> - array of source indices</dd>
<dd><code>dest</code> - dest index</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether it is as long as expected</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if it is not</dd>
</dl>
</li>
</ul>
<a id="confirmEnoughAbsoluteSources(int[][],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>confirmEnoughAbsoluteSources</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;confirmEnoughAbsoluteSources&#8203;(int[][]&nbsp;sourcesAbsolute,
                                            int&nbsp;destAgentRow,
                                            int&nbsp;destAgentColumn)</pre>
<div class="block">Check that the supplied array of absolutes as sources
  is long enough compared to our expectation</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourcesAbsolute</code> - array of 2D source indices</dd>
<dd><code>destAgentRow</code> - row of dest variable</dd>
<dd><code>destAgentColumn</code> - column of dest variable</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether it is as long as expected</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if it is not</dd>
</dl>
</li>
</ul>
<a id="cleanOffsetOfDestFromSources(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cleanOffsetOfDestFromSources</h4>
<pre class="methodSignature">public&nbsp;int[]&nbsp;cleanOffsetOfDestFromSources&#8203;(int[]&nbsp;sourcesOffsets)</pre>
<div class="block">Returns the information contributors to this node which
 are not equal to the node itself (offset 0).
 Checks that there are enough sources.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourcesOffsets</code> - array of source offsets</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>sourcesOffsets with these entries removed
  from the array</dd>
</dl>
</li>
</ul>
<a id="cleanOffsetOfDestFromSources(int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cleanOffsetOfDestFromSources</h4>
<pre class="methodSignature">public&nbsp;int[][]&nbsp;cleanOffsetOfDestFromSources&#8203;(int[][]&nbsp;sourcesOffsets)</pre>
<div class="block">Returns the information contributors to this node which
 are not equal to the node itself (offset (0,0)).
 Checks that there are enough sources.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sourcesOffsets</code> - 2D source offsets. 1st dimension is source index, 2nd index is for
   1st or 2nd index of source indice pair</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>sourcesOffsets with these entries removed
  from the array</dd>
</dl>
</li>
</ul>
<a id="cleanAbsoluteSources(int[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cleanAbsoluteSources</h4>
<pre class="methodSignature">public&nbsp;int[]&nbsp;cleanAbsoluteSources&#8203;(int[]&nbsp;sources,
                                  int&nbsp;dest)</pre>
<div class="block">Returns the information contributors to the dest which
 are not equal to the node itself (offset 0).
 Checks that there are enough other information contributors.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - array of source indices</dd>
<dd><code>dest</code> - dest index</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>sources with these entries removed
  from the array</dd>
</dl>
</li>
</ul>
<a id="cleanAbsoluteSources(int[][],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cleanAbsoluteSources</h4>
<pre class="methodSignature">public&nbsp;int[][]&nbsp;cleanAbsoluteSources&#8203;(int[][]&nbsp;sources,
                                    int&nbsp;destAgentRow,
                                    int&nbsp;destAgentColumn)</pre>
<div class="block">Returns the information contributors to the dest which
 are not equal to the node itself (offset 0).
 Checks that there are enough other information contributors.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sources</code> - 2D array of source indices</dd>
<dd><code>dest</code> - dest index</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>sources with these entries removed
  from the array</dd>
</dl>
</li>
</ul>
<a id="isPeriodicBoundaryConditions()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPeriodicBoundaryConditions</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isPeriodicBoundaryConditions()</pre>
<div class="block">Whether we use periodic boundary conditions when considering
 spatiotemporal data for homogeneous variables</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>if this is the case</dd>
</dl>
</li>
</ul>
<a id="setPeriodicBoundaryConditions(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setPeriodicBoundaryConditions</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setPeriodicBoundaryConditions&#8203;(boolean&nbsp;periodicBoundaryConditions)</pre>
<div class="block">Set whether to use periodic boundary conditions</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>periodicBoundaryConditions</code> - as above</dd>
</dl>
</li>
</ul>
<a id="isComputeMultiInfoCoherence()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isComputeMultiInfoCoherence</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isComputeMultiInfoCoherence()</pre>
<div class="block">Whether the calculator should gather observations to
  compute a multi-info between the local TEs and
  AIS values.
 See Lizier et al, 2012 "Coherent information structure in complex computation"</div>
</li>
</ul>
<a id="setComputeMultiInfoCoherence(java.lang.String,java.util.Properties)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setComputeMultiInfoCoherence</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setComputeMultiInfoCoherence&#8203;(java.lang.String&nbsp;miCoherenceCalculatorClass,
                                         java.util.Properties&nbsp;props)
                                  throws java.lang.Exception</pre>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd>
</dl>
</li>
</ul>
<a id="clearComputeMultiInfoCoherence()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearComputeMultiInfoCoherence</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;clearComputeMultiInfoCoherence()</pre>
</li>
</ul>
<a id="computeMultiInfoCoherence()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeMultiInfoCoherence</h4>
<pre class="methodSignature">public&nbsp;double&nbsp;computeMultiInfoCoherence()
                                 throws java.lang.Exception</pre>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd>
</dl>
</li>
</ul>
<a id="canComputeMultiInfoCoherenceFromAverageOfObservations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>canComputeMultiInfoCoherenceFromAverageOfObservations</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;canComputeMultiInfoCoherenceFromAverageOfObservations()</pre>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the calculator can compute the multi info
  coherence of computation from the averageLocalOfObservations
  method.</dd>
</dl>
</li>
</ul>
<a id="resetMultiInfoCoherenceCalculator()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resetMultiInfoCoherenceCalculator</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;resetMultiInfoCoherenceCalculator()</pre>
<div class="block">Allows reclaiming of some vital memory</div>
</li>
</ul>
<a id="setDebug(boolean)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>setDebug</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setDebug&#8203;(boolean&nbsp;debug)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="InfoMeasureCalculatorDiscrete.html#setDebug(boolean)">InfoMeasureCalculatorDiscrete</a></code></span></div>
<div class="block">Set or clear debug mode for extra debug printing to stdout</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="InfoMeasureCalculatorDiscrete.html#setDebug(boolean)">setDebug</a></code>&nbsp;in class&nbsp;<code><a href="InfoMeasureCalculatorDiscrete.html" title="class in infodynamics.measures.discrete">InfoMeasureCalculatorDiscrete</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>debug</code> - new setting for debug mode (on/off)</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
