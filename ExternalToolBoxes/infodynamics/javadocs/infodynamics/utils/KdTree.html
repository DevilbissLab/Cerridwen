<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.20) on Tue Aug 22 13:03:51 AEST 2023 -->
<title>KdTree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-08-22">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.min.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="KdTree";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":9,"i52":9,"i53":10,"i54":10,"i55":10,"i56":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">infodynamics.utils</a></div>
<h2 title="Class KdTree" class="title">Class KdTree</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">infodynamics.utils.NearestNeighbourSearcher</a></li>
<li>
<ul class="inheritance">
<li>infodynamics.utils.KdTree</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">KdTree</span>
extends <a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></pre>
<div class="block">K-d tree implementation to be used for fast neighbour searching
  across several (multi-dimensional) variables.
 Norms for the nearest neighbour searches are the max norm between
  the (multi-dimensional) variables, and either max norm or Euclidean
  norm (squared) within each variable.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Joseph Lizier (<a href="joseph.lizier at gmail.com">email</a>,
 <a href="http://lizier.me/joseph/">www</a>)</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="http://en.wikipedia.org/wiki/K-d_tree">K-d tree page on wikipedia</a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a></span></code></th>
<td class="colLast">
<div class="block">Protected class to implement nodes of a k-d tree</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- =========== FIELD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected double[][][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dimensionToArray">dimensionToArray</a></span></code></th>
<td class="colLast">
<div class="block">Maps dimension number (first index) to which
  double[][] array holds the data for this dimension,
  and which index we use in that array (dimensionToArrayIndex).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dimensionToArrayIndex">dimensionToArrayIndex</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dimensionToVariableNumber">dimensionToVariableNumber</a></span></code></th>
<td class="colLast">
<div class="block">Variable at index i in the full joint set 
 corresponds to high level variable
 dimensionToVariableNumber[i]; i.e.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#masterSortedArrayIndices">masterSortedArrayIndices</a></span></code></th>
<td class="colLast">
<div class="block">For each dimension dim, sortedArrayIndices[dim] is an array
  of indices to the data in sourceObservations and destObservations,
  sorted in order (min to max) for the dimension dim;
  plus we have a spare dimension for a temporary array.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected double[][][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#originalDataSets">originalDataSets</a></span></code></th>
<td class="colLast">
<div class="block">Cached reference to the data the tree is constructed from.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rootNode">rootNode</a></span></code></th>
<td class="colLast">
<div class="block">The root node for this k-d tree</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#totalDimensions">totalDimensions</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="fields.inherited.from.class.infodynamics.utils.NearestNeighbourSearcher">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;infodynamics.utils.<a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></h3>
<code><a href="NearestNeighbourSearcher.html#normTypeToUse">normTypeToUse</a></code></li>
</ul>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(double%5B%5D%5B%5D)">KdTree</a></span>&#8203;(double[][]&nbsp;data)</code></th>
<td class="colLast">
<div class="block">Construct the k-d tree from a set of double[][] data.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(int%5B%5D,double%5B%5D%5B%5D%5B%5D)">KdTree</a></span>&#8203;(int[]&nbsp;dimensions,
      double[][][]&nbsp;data)</code></th>
<td class="colLast">
<div class="block">Construct the k-d tree from a <b>set</b> of double[][] data,
 considered jointly.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#constructKdTree(int,int,int,int%5B%5D%5B%5D)">constructKdTree</a></span>&#8203;(int&nbsp;currentDim,
               int&nbsp;startPoint,
               int&nbsp;numPoints,
               int[][]&nbsp;sortedArrayIndices)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsStrictlyWithinR(int,double,int,boolean%5B%5D)">countPointsStrictlyWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                          double&nbsp;r,
                          int&nbsp;variableAlreadyTested,
                          boolean[]&nbsp;testResultsForGivenVariable)</code></th>
<td class="colLast">
<div class="block">As per <a href="#countPointsWithinR(int,double,boolean,int,boolean%5B%5D)"><code>countPointsWithinR(int, double, boolean, int, boolean[])</code></a>
 with allowEqualToR == false</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsStrictlyWithinRs(int,double%5B%5D)">countPointsStrictlyWithinRs</a></span>&#8203;(int&nbsp;sampleIndex,
                           double[]&nbsp;rs)</code></th>
<td class="colLast">
<div class="block">Count the number of points strictly within norms {r1,r2,etc} for each high-level
  variable, for a given
  sample index in the data set.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsStrictlyWithinRs(int,double%5B%5D,int,boolean%5B%5D)">countPointsStrictlyWithinRs</a></span>&#8203;(int&nbsp;sampleIndex,
                           double[]&nbsp;rs,
                           int&nbsp;variableAlreadyTested,
                           boolean[]&nbsp;testResultsForGivenVariable)</code></th>
<td class="colLast">
<div class="block">As per <a href="#countPointsWithinRs(int,double%5B%5D,boolean,int,boolean%5B%5D)"><code>countPointsWithinRs(int, double[], boolean, int, boolean[])</code></a>
 with allowEqualToR == false</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinOrOnR(int,double,int,boolean%5B%5D)">countPointsWithinOrOnR</a></span>&#8203;(int&nbsp;sampleIndex,
                      double&nbsp;r,
                      int&nbsp;variableAlreadyTested,
                      boolean[]&nbsp;testResultsForGivenVariable)</code></th>
<td class="colLast">
<div class="block">As per <a href="#countPointsWithinR(int,double,boolean,int,boolean%5B%5D)"><code>countPointsWithinR(int, double, boolean, int, boolean[])</code></a>
 with allowEqualToR == true</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinOrOnRs(int,double%5B%5D)">countPointsWithinOrOnRs</a></span>&#8203;(int&nbsp;sampleIndex,
                       double[]&nbsp;rs)</code></th>
<td class="colLast">
<div class="block">Count the number of points within or at norms {r1,r2,etc} for each high-level
  variable, for a given
  sample index in the data set.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinOrOnRs(int,double%5B%5D,int,boolean%5B%5D)">countPointsWithinOrOnRs</a></span>&#8203;(int&nbsp;sampleIndex,
                       double[]&nbsp;rs,
                       int&nbsp;variableAlreadyTested,
                       boolean[]&nbsp;testResultsForGivenVariable)</code></th>
<td class="colLast">
<div class="block">As per <a href="#countPointsWithinRs(int,double%5B%5D,boolean,int,boolean%5B%5D)"><code>countPointsWithinRs(int, double[], boolean, int, boolean[])</code></a>
 with allowEqualToR == true</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(double%5B%5D%5B%5D,double,boolean)">countPointsWithinR</a></span>&#8203;(double[][]&nbsp;sampleVectors,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR)</code></th>
<td class="colLast">
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however the search is to match a specified sample point (not a sample
 point within the search space itself).</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(double%5B%5D%5B%5D,double,boolean,boolean%5B%5D)">countPointsWithinR</a></span>&#8203;(double[][]&nbsp;sampleVectors,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;additionalCriteria)</code></th>
<td class="colLast">
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(double%5B%5D%5B%5D,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(double[][], double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(double%5B%5D%5B%5D,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean)">countPointsWithinR</a></span>&#8203;(double[][]&nbsp;sampleVectors,
                  <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR)</code></th>
<td class="colLast">
<div class="block">Count the number of points within radius r of a given sample (sampleVector),
 in the tree rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(double%5B%5D%5B%5D,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean%5B%5D)">countPointsWithinR</a></span>&#8203;(double[][]&nbsp;sampleVectors,
                  <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;additionalCriteria)</code></th>
<td class="colLast">
<div class="block">Count the number of points within radius r of a given sample (sampleVectors -- from outside the tree),
 in the tree rooted at node (which is at the specified level in the tree),
 subject to an additional criteria.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(double%5B%5D%5B%5D,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,int,boolean%5B%5D)">countPointsWithinR</a></span>&#8203;(double[][]&nbsp;sampleVectors,
                  <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  int&nbsp;variableAlreadyTested,
                  boolean[]&nbsp;testResultsForGivenVariable)</code></th>
<td class="colLast">
<div class="block">Count the number of points within radius r of a given sample (sampleVectors),
 in the tree rooted at node (which is at the specified level in the tree),
 when one of the variables has already been tested.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(double,double%5B%5D%5B%5D,boolean,int,boolean%5B%5D)">countPointsWithinR</a></span>&#8203;(double&nbsp;r,
                  double[][]&nbsp;sampleVectors,
                  boolean&nbsp;allowEqualToR,
                  int&nbsp;variableAlreadyTested,
                  boolean[]&nbsp;testResultsForGivenVariable)</code></th>
<td class="colLast">
<div class="block">As per <a href="#countPointsWithinR(int,double,boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>, except searches for a specified
 sample point rather than a point associated with an index in the existing sample set, and
 with an additional factor as follows.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(int,double,boolean)">countPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR)</code></th>
<td class="colLast">
<div class="block">Count the number of points within norm r for a given
  sample index in the data set.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(int,double,boolean,boolean%5B%5D)">countPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;additionalCriteria)</code></th>
<td class="colLast">
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(int,double,boolean,boolean%5B%5D,int%5B%5D)">countPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;additionalCriteria,
                  int[]&nbsp;remapping)</code></th>
<td class="colLast">
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria, 
 and the search points are reindexed according to the remapping
 specified in remapping</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(int,double,boolean,int,boolean%5B%5D)">countPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  int&nbsp;variableAlreadyTested,
                  boolean[]&nbsp;testResultsForGivenVariable)</code></th>
<td class="colLast">
<div class="block">As per <a href="#countPointsWithinR(int,double,boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 with an additional factor as follows.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(int,double,int,boolean)">countPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  int&nbsp;dynCorrExclTime,
                  boolean&nbsp;allowEqualToR)</code></th>
<td class="colLast">
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however any nodes within dynCorrExclTime are excluded from
 the search.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean)">countPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                  <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR)</code></th>
<td class="colLast">
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean%5B%5D)">countPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                  <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;additionalCriteria)</code></th>
<td class="colLast">
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 subject to an additional criteria.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean%5B%5D,int%5B%5D)">countPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                  <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;additionalCriteria,
                  int[]&nbsp;remapping)</code></th>
<td class="colLast">
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 subject to an additional criteria,
 and the search points are reindexed according to the remapping specified in remapping.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,int,boolean%5B%5D)">countPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                  <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  int&nbsp;variableAlreadyTested,
                  boolean[]&nbsp;testResultsForGivenVariable)</code></th>
<td class="colLast">
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 when one of the variables has already been tested.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,int,boolean)">countPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                  <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double&nbsp;r,
                  int&nbsp;dynCorrExclTime,
                  boolean&nbsp;allowEqualToR)</code></th>
<td class="colLast">
<div class="block">As per <a href="#countPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean)"><code>countPointsWithinR(int, KdTreeNode, int, double, boolean)</code></a>
 however excludes points within dynCorrExclTime of node
 from being counted.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinRs(int,double%5B%5D,boolean)">countPointsWithinRs</a></span>&#8203;(int&nbsp;sampleIndex,
                   double[]&nbsp;rs,
                   boolean&nbsp;allowEqualToR)</code></th>
<td class="colLast">
<div class="block">Count the number of points within norms {r1,r2,etc} for each high-level
  variable, for a given
  sample index in the data set.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinRs(int,double%5B%5D,boolean,int,boolean%5B%5D)">countPointsWithinRs</a></span>&#8203;(int&nbsp;sampleIndex,
                   double[]&nbsp;rs,
                   boolean&nbsp;allowEqualToR,
                   int&nbsp;variableAlreadyTested,
                   boolean[]&nbsp;testResultsForGivenVariable)</code></th>
<td class="colLast">
<div class="block">As per <a href="#countPointsWithinRs(int,double%5B%5D,boolean)"><code>countPointsWithinRs(int, double[], boolean)</code></a>
 with an additional factor as follows.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinRs(int,infodynamics.utils.KdTree.KdTreeNode,int,double%5B%5D,boolean)">countPointsWithinRs</a></span>&#8203;(int&nbsp;sampleIndex,
                   <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                   int&nbsp;level,
                   double[]&nbsp;rs,
                   boolean&nbsp;allowEqualToR)</code></th>
<td class="colLast">
<div class="block">Count the number of points within norms {r1,r2,etc} for each high-level
  variable, for a given
  sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countPointsWithinRs(int,infodynamics.utils.KdTree.KdTreeNode,int,double%5B%5D,boolean,int,boolean%5B%5D)">countPointsWithinRs</a></span>&#8203;(int&nbsp;sampleIndex,
                   <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                   int&nbsp;level,
                   double[]&nbsp;rs,
                   boolean&nbsp;allowEqualToR,
                   int&nbsp;variableAlreadyTested,
                   boolean[]&nbsp;testResultsForGivenVariable)</code></th>
<td class="colLast">
<div class="block">Count the number of points within norms {r1,r2,etc} for each high-level
  variable, for a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 when one of the variables has already been tested.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>java.util.PriorityQueue&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findKNearestNeighbours(int,double%5B%5D%5B%5D)">findKNearestNeighbours</a></span>&#8203;(int&nbsp;K,
                      double[][]&nbsp;sampleVectors)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findKNearestNeighbours(int,double%5B%5D%5B%5D,infodynamics.utils.KdTree.KdTreeNode,int,java.util.PriorityQueue)">findKNearestNeighbours</a></span>&#8203;(int&nbsp;K,
                      double[][]&nbsp;sampleVectors,
                      <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                      int&nbsp;level,
                      java.util.PriorityQueue&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;currentKBest)</code></th>
<td class="colLast">
<div class="block">Protected method to Update the k nearest neighbours to a given sample (samplePoint), from the tree
 rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>java.util.PriorityQueue&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findKNearestNeighbours(int,int)">findKNearestNeighbours</a></span>&#8203;(int&nbsp;K,
                      int&nbsp;sampleIndex)</code></th>
<td class="colLast">
<div class="block">Return the K nodes which are the K nearest neighbours for a given
  sample index in the data set.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>java.util.PriorityQueue&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findKNearestNeighbours(int,int,int)">findKNearestNeighbours</a></span>&#8203;(int&nbsp;K,
                      int&nbsp;sampleIndex,
                      int&nbsp;dynCorrExclTime)</code></th>
<td class="colLast">
<div class="block">Return the K nodes which are the K nearest neighbours for a given
  sample index in the data set.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findKNearestNeighbours(int,int,int,infodynamics.utils.KdTree.KdTreeNode,int,java.util.PriorityQueue)">findKNearestNeighbours</a></span>&#8203;(int&nbsp;K,
                      int&nbsp;sampleIndex,
                      int&nbsp;dynCorrExclTime,
                      <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                      int&nbsp;level,
                      java.util.PriorityQueue&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;currentKBest)</code></th>
<td class="colLast">
<div class="block">Protected method to Update the k nearest neighbours to a given sample (sampleIndex), from the tree
 rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findKNearestNeighbours(int,int,infodynamics.utils.KdTree.KdTreeNode,int,java.util.PriorityQueue)">findKNearestNeighbours</a></span>&#8203;(int&nbsp;K,
                      int&nbsp;sampleIndex,
                      <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                      int&nbsp;level,
                      java.util.PriorityQueue&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;currentKBest)</code></th>
<td class="colLast">
<div class="block">Protected method to Update the k nearest neighbours to a given sample (sampleIndex), from the tree
 rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findNearestNeighbour(int)">findNearestNeighbour</a></span>&#8203;(int&nbsp;sampleIndex)</code></th>
<td class="colLast">
<div class="block">Return the node which is the nearest neighbour for a given
  sample index in the data set.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>protected <a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findNearestNeighbour(int,infodynamics.utils.KdTree.KdTreeNode,int,infodynamics.utils.NeighbourNodeData)">findNearestNeighbour</a></span>&#8203;(int&nbsp;sampleIndex,
                    <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                    int&nbsp;level,
                    <a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&nbsp;currentBest)</code></th>
<td class="colLast">
<div class="block">Find the nearest neighbour to a given sample (sampleIndex), in the tree
 rooted at node (which is at the specified level in the tree), or
 return currentBest if no better match is found.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinR(double%5B%5D%5B%5D,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean%5B%5D,int%5B%5D,int)">findPointsWithinR</a></span>&#8203;(double[][]&nbsp;sampleVectors,
                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                 int&nbsp;level,
                 double&nbsp;r,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR,
                 int&nbsp;nextIndexInIndicesWithinR)</code></th>
<td class="colLast">
<div class="block">Record the collection of points within radius r of a given sample (sampleVectors),
 in the tree rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinR(double,double%5B%5D%5B%5D,boolean,boolean%5B%5D,int%5B%5D)">findPointsWithinR</a></span>&#8203;(double&nbsp;r,
                 double[][]&nbsp;samplePoint,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR)</code></th>
<td class="colLast">
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however records the nearest neighbours for a sample data point
  (which may not be in the search tree), within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>java.util.Collection&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinR(int,double,boolean)">findPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                 double&nbsp;r,
                 boolean&nbsp;allowEqualToR)</code></th>
<td class="colLast">
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however returns a collection rather than a count.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinR(int,double,boolean,boolean%5B%5D,int%5B%5D)">findPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                 double&nbsp;r,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR)</code></th>
<td class="colLast">
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however records the nearest neighbours made within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinR(int,double,int,boolean,boolean%5B%5D,double%5B%5D,double%5B%5D%5B%5D)">findPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                 double&nbsp;r,
                 int&nbsp;dynCorrExclTime,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 double[]&nbsp;distancesWithinRInOrder,
                 double[][]&nbsp;distancesAndIndicesWithinR)</code></th>
<td class="colLast">
<div class="block">As per <a href="NearestNeighbourSearcher.html#findPointsWithinR(int,double,boolean,boolean%5B%5D,int%5B%5D)"><code>NearestNeighbourSearcher.findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 however incorporates dynamic correlation exclusion.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinR(int,double,int,boolean,boolean%5B%5D,int%5B%5D)">findPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                 double&nbsp;r,
                 int&nbsp;dynCorrExclTime,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR)</code></th>
<td class="colLast">
<div class="block">As per <a href="NearestNeighbourSearcher.html#findPointsWithinR(int,double,boolean,boolean%5B%5D,int%5B%5D)"><code>NearestNeighbourSearcher.findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 however incorporates dynamic correlation exclusion.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean%5B%5D,int%5B%5D,int)">findPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                 int&nbsp;level,
                 double&nbsp;r,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR,
                 int&nbsp;nextIndexInIndicesWithinR)</code></th>
<td class="colLast">
<div class="block">Record the collection of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,java.util.Collection)">findPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                 int&nbsp;level,
                 double&nbsp;r,
                 boolean&nbsp;allowEqualToR,
                 java.util.Collection&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;pointsWithinR)</code></th>
<td class="colLast">
<div class="block">Add to the collection of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,int,boolean,boolean%5B%5D,double%5B%5D,double%5B%5D%5B%5D,int)">findPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                 int&nbsp;level,
                 double&nbsp;r,
                 int&nbsp;dynCorrExclTime,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 double[]&nbsp;distancesWithinRInOrder,
                 double[][]&nbsp;distancesAndIndicesWithinR,
                 int&nbsp;nextIndexInIndicesWithinR)</code></th>
<td class="colLast">
<div class="block">As per <a href="#findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean%5B%5D,int%5B%5D,int)"><code>findPointsWithinR(int, KdTreeNode, int, double, boolean, boolean[], int[], int)</code></a>
  however with dynamic correlation time specified, and 
  returning distances to neighbours as well as neighbour indices.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,int,boolean,boolean%5B%5D,int%5B%5D,int)">findPointsWithinR</a></span>&#8203;(int&nbsp;sampleIndex,
                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                 int&nbsp;level,
                 double&nbsp;r,
                 int&nbsp;dynCorrExclTime,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR,
                 int&nbsp;nextIndexInIndicesWithinR)</code></th>
<td class="colLast">
<div class="block">As per <a href="#findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean%5B%5D,int%5B%5D,int)"><code>findPointsWithinR(int, KdTreeNode, int, double, boolean, boolean[], int[], int)</code></a>
  however with dynamic correlation time specified</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinRAndTakeRadiusMax(int,double,int,boolean,int,boolean%5B%5D,double%5B%5D,double%5B%5D%5B%5D)">findPointsWithinRAndTakeRadiusMax</a></span>&#8203;(int&nbsp;sampleIndex,
                                 double&nbsp;r,
                                 int&nbsp;dynCorrExclTime,
                                 boolean&nbsp;allowEqualToR,
                                 int&nbsp;variableAlreadyTested,
                                 boolean[]&nbsp;testResultsForGivenVariable,
                                 double[]&nbsp;distancesWithinRForGivenVariable,
                                 double[][]&nbsp;distancesAndIndicesWithinR)</code></th>
<td class="colLast">
<div class="block">As per <a href="#findPointsWithinR(int,double,int,boolean,boolean%5B%5D,double%5B%5D,double%5B%5D%5B%5D)"><code>findPointsWithinR(int, double, int, boolean, boolean[], double[], double[][])</code></a>
 only we have a sub-variable already tested, and we incorporate its results here.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinRAndTakeRadiusMax(int,infodynamics.utils.KdTree.KdTreeNode,int,double,int,boolean,int,boolean%5B%5D,double%5B%5D,double%5B%5D%5B%5D,int)">findPointsWithinRAndTakeRadiusMax</a></span>&#8203;(int&nbsp;sampleIndex,
                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                 int&nbsp;level,
                                 double&nbsp;r,
                                 int&nbsp;dynCorrExclTime,
                                 boolean&nbsp;allowEqualToR,
                                 int&nbsp;variableAlreadyTested,
                                 boolean[]&nbsp;testResultsForGivenVariable,
                                 double[]&nbsp;distancesWithinRForGivenVariable,
                                 double[][]&nbsp;distancesAndIndicesWithinR,
                                 int&nbsp;nextIndexInIndicesWithinR)</code></th>
<td class="colLast">
<div class="block">As per <a href="#findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,int,boolean,boolean%5B%5D,double%5B%5D,double%5B%5D%5B%5D,int)"><code>findPointsWithinR(int, KdTreeNode, int, double, int, boolean, boolean[], double[], double[][], int)</code></a>
 only we have a sub-variable already tested, and we incorporate its results here.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinRs(double%5B%5D%5B%5D,infodynamics.utils.KdTree.KdTreeNode,int,double%5B%5D,boolean,boolean%5B%5D,int%5B%5D,int)">findPointsWithinRs</a></span>&#8203;(double[][]&nbsp;sampleVectors,
                  <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double[]&nbsp;rs,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;isWithinR,
                  int[]&nbsp;indicesWithinR,
                  int&nbsp;nextIndexInIndicesWithinR)</code></th>
<td class="colLast">
<div class="block">Record the collection of points within radii rs of a given sample (sampleVectors),
 in the tree rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinRs(double%5B%5D,double%5B%5D%5B%5D,boolean,boolean%5B%5D,int%5B%5D)">findPointsWithinRs</a></span>&#8203;(double[]&nbsp;rs,
                  double[][]&nbsp;samplePoint,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;isWithinR,
                  int[]&nbsp;indicesWithinR)</code></th>
<td class="colLast">
<div class="block">As per {@link #findPointsWithinR(double[], double[][], boolean, boolean[], int[]))}
  however using multiple radii for each variable.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinRs(int,double%5B%5D,int,boolean,boolean%5B%5D,int%5B%5D)">findPointsWithinRs</a></span>&#8203;(int&nbsp;sampleIndex,
                  double[]&nbsp;rs,
                  int&nbsp;dynCorrExclTime,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;isWithinR,
                  int[]&nbsp;indicesWithinR)</code></th>
<td class="colLast">
<div class="block">As per <a href="#findPointsWithinR(int,double,int,boolean,boolean%5B%5D,int%5B%5D)"><code>findPointsWithinR(int, double, int, boolean, boolean[], int[])</code></a>
  however using multiple radii for each variable.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findPointsWithinRs(int,infodynamics.utils.KdTree.KdTreeNode,int,double%5B%5D,int,boolean,boolean%5B%5D,int%5B%5D,int)">findPointsWithinRs</a></span>&#8203;(int&nbsp;sampleIndex,
                  <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double[]&nbsp;rs,
                  int&nbsp;dynCorrExclTime,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;isWithinR,
                  int[]&nbsp;indicesWithinR,
                  int&nbsp;nextIndexInIndicesWithinR)</code></th>
<td class="colLast">
<div class="block">As per <a href="#findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,int,boolean,boolean%5B%5D,int%5B%5D,int)"><code>findPointsWithinR(int, KdTreeNode, int, double, int, boolean, boolean[], int[], int)</code></a>
  however with dynamic correlation time specified</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#norm(double%5B%5D,double%5B%5D,int)">norm</a></span>&#8203;(double[]&nbsp;x1,
    double[]&nbsp;x2,
    int&nbsp;normToUse)</code></th>
<td class="colLast">
<div class="block">Computing the configured norm between vectors x1 and x2.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#normWithAbort(double%5B%5D,double%5B%5D,double,int)">normWithAbort</a></span>&#8203;(double[]&nbsp;x1,
             double[]&nbsp;x2,
             double&nbsp;limit,
             int&nbsp;normToUse)</code></th>
<td class="colLast">
<div class="block">Computing the configured norm between vectors x1 and x2; if 
  it becomes clear that norm will be larger than limit,
  then return Double.POSITIVE_INFINITY immediately.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#print()">print</a></span>()</code></th>
<td class="colLast">
<div class="block">Internal utility function for debug printing of a tree</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#print(infodynamics.utils.KdTree.KdTreeNode,int)">print</a></span>&#8203;(<a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
     int&nbsp;level)</code></th>
<td class="colLast">
<div class="block">Internal utility function for debug printing of a node and
  all of its descendants</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNormType(int)">setNormType</a></span>&#8203;(int&nbsp;normType)</code></th>
<td class="colLast">
<div class="block">Set the norm type to use in the nearest neighbour searches,
  to normType.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setNormType(java.lang.String)">setNormType</a></span>&#8203;(java.lang.String&nbsp;normTypeString)</code></th>
<td class="colLast">
<div class="block">Set the norm type to use to normType.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.infodynamics.utils.NearestNeighbourSearcher">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;infodynamics.utils.<a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></h3>
<code><a href="NearestNeighbourSearcher.html#convertNormTypeToString(int)">convertNormTypeToString</a>, <a href="NearestNeighbourSearcher.html#countPointsStrictlyWithinR(int,double)">countPointsStrictlyWithinR</a>, <a href="NearestNeighbourSearcher.html#countPointsStrictlyWithinR(int,double,int)">countPointsStrictlyWithinR</a>, <a href="NearestNeighbourSearcher.html#countPointsWithinOrOnR(int,double)">countPointsWithinOrOnR</a>, <a href="NearestNeighbourSearcher.html#countPointsWithinOrOnR(int,double,int)">countPointsWithinOrOnR</a>, <a href="NearestNeighbourSearcher.html#create(double%5B%5D%5B%5D)">create</a>, <a href="NearestNeighbourSearcher.html#create(int%5B%5D,double%5B%5D%5B%5D%5B%5D)">create</a>, <a href="NearestNeighbourSearcher.html#findPointsStrictlyWithinR(int,double)">findPointsStrictlyWithinR</a>, <a href="NearestNeighbourSearcher.html#findPointsStrictlyWithinR(int,double,boolean%5B%5D,int%5B%5D)">findPointsStrictlyWithinR</a>, <a href="NearestNeighbourSearcher.html#findPointsWithinOrOnR(int,double)">findPointsWithinOrOnR</a>, <a href="NearestNeighbourSearcher.html#findPointsWithinOrOnR(int,double,boolean%5B%5D,int%5B%5D)">findPointsWithinOrOnR</a>, <a href="NearestNeighbourSearcher.html#getNormType()">getNormType</a>, <a href="NearestNeighbourSearcher.html#getNormTypeAsString()">getNormTypeAsString</a>, <a href="NearestNeighbourSearcher.html#validateNormType(java.lang.String)">validateNormType</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="originalDataSets">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>originalDataSets</h4>
<pre>protected&nbsp;double[][][] originalDataSets</pre>
<div class="block">Cached reference to the data the tree is constructed from.
 We have an array of double[][] 2D arrays -- each 2D array 
 originalDataSets[i] is 
 considered as a separate (multivariate) variable (indexed by sample
 number then dimension number), whilst the set of all such
 arrays is considered a joint variable of multivariates.</div>
</li>
</ul>
<a id="masterSortedArrayIndices">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>masterSortedArrayIndices</h4>
<pre>protected&nbsp;int[][] masterSortedArrayIndices</pre>
<div class="block">For each dimension dim, sortedArrayIndices[dim] is an array
  of indices to the data in sourceObservations and destObservations,
  sorted in order (min to max) for the dimension dim;
  plus we have a spare dimension for a temporary array.
 This is only used in the construction of the kd tree.</div>
</li>
</ul>
<a id="dimensionToArray">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dimensionToArray</h4>
<pre>protected&nbsp;double[][][] dimensionToArray</pre>
<div class="block">Maps dimension number (first index) to which
  double[][] array holds the data for this dimension,
  and which index we use in that array (dimensionToArrayIndex).
  
 I.e. for a dimension number d (out of the joint variables
 across all the multivariates in originalDataSets), 
 dimensionToArray[d] points to the relevant originalDataSets[i]
 multivariate, while dimensionToArrayIndex[d] tells us which 
 variable within originalDataSets[i] to use, i.e. the time series
 originalDataSets[i][t][dimensionToArrayIndex[d]] for time variable t
 is the relevant time-series for dimension number d.</div>
</li>
</ul>
<a id="dimensionToArrayIndex">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dimensionToArrayIndex</h4>
<pre>protected&nbsp;int[] dimensionToArrayIndex</pre>
</li>
</ul>
<a id="dimensionToVariableNumber">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dimensionToVariableNumber</h4>
<pre>protected&nbsp;int[] dimensionToVariableNumber</pre>
<div class="block">Variable at index i in the full joint set 
 corresponds to high level variable
 dimensionToVariableNumber[i]; i.e. the
 originalDataSets[dimensionToVariableNumber[i]] 2D array.</div>
</li>
</ul>
<a id="totalDimensions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>totalDimensions</h4>
<pre>protected&nbsp;int totalDimensions</pre>
</li>
</ul>
<a id="rootNode">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>rootNode</h4>
<pre>protected&nbsp;<a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a> rootNode</pre>
<div class="block">The root node for this k-d tree</div>
</li>
</ul>
</li>
</ul>
</section>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>KdTree</h4>
<pre>public&nbsp;KdTree&#8203;(double[][]&nbsp;data)</pre>
<div class="block">Construct the k-d tree from a set of double[][] data.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>data</code> - a double[][] 2D data set, first indexed
  by time, second index by variable number.</dd>
</dl>
</li>
</ul>
<a id="&lt;init&gt;(int[],double[][][])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>KdTree</h4>
<pre>public&nbsp;KdTree&#8203;(int[]&nbsp;dimensions,
              double[][][]&nbsp;data)</pre>
<div class="block">Construct the k-d tree from a <b>set</b> of double[][] data,
 considered jointly.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dimensions</code> - an array of dimensions for each
  of the 2D data sets.</dd>
<dd><code>data</code> - an array of double[][] 2D data sets
  for each data[i]
  (where i is the main variable number within data, then
   after that the first index is sample number, second is dimension
   within this data set)</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section>
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="constructKdTree(int,int,int,int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>constructKdTree</h4>
<pre class="methodSignature">protected&nbsp;<a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;constructKdTree&#8203;(int&nbsp;currentDim,
                                            int&nbsp;startPoint,
                                            int&nbsp;numPoints,
                                            int[][]&nbsp;sortedArrayIndices)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>currentDim</code> - the dimension that we're currently working with</dd>
<dd><code>startPoint</code> - the index of the first point for us to add here,
   in the sorted array of points for currentDim</dd>
<dd><code>numPoints</code> - the number of points for us to add here,
   in the sorted array of points for currentDim</dd>
<dd><code>sortedArrayIndices</code> - for each dimension dim, sortedArrayIndices[dim] is an array
  of indices to the data in sourceObservations and destObservations,
  sorted in order (min to max) for the dimension dim. This is only valid
  between startPoint and startPoint + numPoints-1 however; nothing outside
  this should be touched. There is one extra dimension here, which may be used
  as a temporary array (though again, only between startPoint and
  startPoint + numPoints-1 should be touched).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
</dl>
</li>
</ul>
<a id="setNormType(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNormType</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setNormType&#8203;(int&nbsp;normType)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#setNormType(int)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">Set the norm type to use in the nearest neighbour searches,
  to normType.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#setNormType(int)">setNormType</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>normType</code> - norm type to use; must be either
  <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a>,
  <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> or
  <a href="EuclideanUtils.html#NORM_MAX_NORM"><code>EuclideanUtils.NORM_MAX_NORM</code></a>, otherwise an
  UnsupportedOperationException is thrown.
  <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> will be nominally supported
  but switched to
  <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally for speed.</dd>
</dl>
</li>
</ul>
<a id="setNormType(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNormType</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setNormType&#8203;(java.lang.String&nbsp;normTypeString)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#setNormType(java.lang.String)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">Set the norm type to use to normType.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#setNormType(java.lang.String)">setNormType</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>normTypeString</code> - norm type to use; must be either
  <a href="EuclideanUtils.html#NORM_EUCLIDEAN_STRING"><code>EuclideanUtils.NORM_EUCLIDEAN_STRING</code></a>,
  <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED_STRING"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED_STRING</code></a> or
  <a href="EuclideanUtils.html#NORM_MAX_NORM_STRING"><code>EuclideanUtils.NORM_MAX_NORM_STRING</code></a>, otherwise an
  UnsupportedOperationException is thrown.
  <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> will be nominally supported
  but switched to
  <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally for speed.</dd>
</dl>
</li>
</ul>
<a id="norm(double[],double[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>norm</h4>
<pre class="methodSignature">public static final&nbsp;double&nbsp;norm&#8203;(double[]&nbsp;x1,
                                double[]&nbsp;x2,
                                int&nbsp;normToUse)</pre>
<div class="block">Computing the configured norm between vectors x1 and x2.
 Adding here instead of using <a href="EuclideanUtils.html#norm(double%5B%5D,double%5B%5D)"><code>EuclideanUtils.norm(double[], double[])</code></a>
 to attempt speed-up.
 Also hoping this method is inlined by the JVM, but haven't checked this.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x1</code> - vector of doubles</dd>
<dd><code>x2</code> - vector of doubles</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the selected norm</dd>
</dl>
</li>
</ul>
<a id="normWithAbort(double[],double[],double,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normWithAbort</h4>
<pre class="methodSignature">public static final&nbsp;double&nbsp;normWithAbort&#8203;(double[]&nbsp;x1,
                                         double[]&nbsp;x2,
                                         double&nbsp;limit,
                                         int&nbsp;normToUse)</pre>
<div class="block">Computing the configured norm between vectors x1 and x2; if 
  it becomes clear that norm will be larger than limit,
  then return Double.POSITIVE_INFINITY immediately.
 
 <p>Adding here instead of using <a href="EuclideanUtils.html#normWithAbort(double%5B%5D,double%5B%5D,double)"><code>EuclideanUtils.normWithAbort(double[], double[], double)</code></a>
 to attempt speed-up.
 Also hoping this method is inlined by the JVM, but haven't checked this.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x1</code> - vector 1 of doubles</dd>
<dd><code>x2</code> - vector 2 of doubles</dd>
<dd><code>limit</code> - if it becomes clear that norm will be larger than limit,
  then return Double.POSITIVE_INFINITY immediately.</dd>
<dd><code>normToUse</code> - which norm to use, as defined by <a href="#setNormType(int)"><code>setNormType(int)</code></a></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the selected norm</dd>
</dl>
</li>
</ul>
<a id="findNearestNeighbour(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findNearestNeighbour</h4>
<pre class="methodSignature">public&nbsp;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&nbsp;findNearestNeighbour&#8203;(int&nbsp;sampleIndex)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#findNearestNeighbour(int)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">Return the node which is the nearest neighbour for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#findNearestNeighbour(int)">findNearestNeighbour</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the node for the nearest neighbour.</dd>
</dl>
</li>
</ul>
<a id="findNearestNeighbour(int,infodynamics.utils.KdTree.KdTreeNode,int,infodynamics.utils.NeighbourNodeData)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findNearestNeighbour</h4>
<pre class="methodSignature">protected&nbsp;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&nbsp;findNearestNeighbour&#8203;(int&nbsp;sampleIndex,
                                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                                 int&nbsp;level,
                                                 <a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&nbsp;currentBest)</pre>
<div class="block">Find the nearest neighbour to a given sample (sampleIndex), in the tree
 rooted at node (which is at the specified level in the tree), or
 return currentBest if no better match is found.
 Nearest neighbour is a max norm between the high-level variables,
 with norm for each variable being the specified norm.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>currentBest</code> - a NeighbourNodeData structure capturing the current
  closest neighbour and its distance</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the node data for the nearest neighbour.</dd>
</dl>
</li>
</ul>
<a id="findKNearestNeighbours(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findKNearestNeighbours</h4>
<pre class="methodSignature">public&nbsp;java.util.PriorityQueue&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;findKNearestNeighbours&#8203;(int&nbsp;K,
                                                                         int&nbsp;sampleIndex)
                                                                  throws java.lang.Exception</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#findKNearestNeighbours(int,int)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">Return the K nodes which are the K nearest neighbours for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#findKNearestNeighbours(int,int)">findKNearestNeighbours</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>K</code> - number of K nearest neighbours to return, sorted from
  furthest away first to nearest last.</dd>
<dd><code>sampleIndex</code> - sample index in the data to find the K nearest neighbours
  for</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a PriorityQueue of nodes for the K nearest neighbours,
  sorted with furthest neighbour first in the PQ.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd>
</dl>
</li>
</ul>
<a id="findKNearestNeighbours(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findKNearestNeighbours</h4>
<pre class="methodSignature">public&nbsp;java.util.PriorityQueue&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;findKNearestNeighbours&#8203;(int&nbsp;K,
                                                                         int&nbsp;sampleIndex,
                                                                         int&nbsp;dynCorrExclTime)
                                                                  throws java.lang.Exception</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#findKNearestNeighbours(int,int,int)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">Return the K nodes which are the K nearest neighbours for a given
  sample index in the data set. Nodes within dynCorrExclTime time points
  are excluded from the search.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#findKNearestNeighbours(int,int,int)">findKNearestNeighbours</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>K</code> - number of K nearest neighbours to return, sorted from
  furthest away first to nearest last.</dd>
<dd><code>sampleIndex</code> - sample index in the data to find the K nearest neighbours
  for</dd>
<dd><code>dynCorrExclTime</code> - Range around sampleIndex to exclude points from the count. Is >= 0.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a PriorityQueue of nodes for the K nearest neighbours,
  sorted with furthest neighbour first in the PQ.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd>
</dl>
</li>
</ul>
<a id="findKNearestNeighbours(int,int,infodynamics.utils.KdTree.KdTreeNode,int,java.util.PriorityQueue)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findKNearestNeighbours</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;findKNearestNeighbours&#8203;(int&nbsp;K,
                                      int&nbsp;sampleIndex,
                                      <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                      int&nbsp;level,
                                      java.util.PriorityQueue&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;currentKBest)</pre>
<div class="block">Protected method to Update the k nearest neighbours to a given sample (sampleIndex), from the tree
 rooted at node (which is at the specified level in the tree).
 Incorporate neighbours found in this sub-tree into the PriorityQueue
 of the current K closest.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>K</code> - the number of nearest neighbour</dd>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>currentKBest</code> - a PriorityQueue of NeighbourNodeData objects
   capturing the current K closest neighbours and their distances.
   Assumed not to be null, but may be empty or with less than K elements
   so far. It must be sorted from furthest away first to nearest last.</dd>
</dl>
</li>
</ul>
<a id="findKNearestNeighbours(int,int,int,infodynamics.utils.KdTree.KdTreeNode,int,java.util.PriorityQueue)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findKNearestNeighbours</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;findKNearestNeighbours&#8203;(int&nbsp;K,
                                      int&nbsp;sampleIndex,
                                      int&nbsp;dynCorrExclTime,
                                      <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                      int&nbsp;level,
                                      java.util.PriorityQueue&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;currentKBest)</pre>
<div class="block">Protected method to Update the k nearest neighbours to a given sample (sampleIndex), from the tree
 rooted at node (which is at the specified level in the tree).
 Incorporate neighbours found in this sub-tree into the PriorityQueue
 of the current K closest.
 Make sure to exclude any points within dynCorrExclTime of sampleIndex
  from being included in the k NNs.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>K</code> - the number of nearest neighbour</dd>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>dynCorrExclTime</code> - size of dynamic correlation exclusion time window
  on either side of sampleIndex. 0 means exclude only sampleIndex itself.</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>currentKBest</code> - a PriorityQueue of NeighbourNodeData objects
   capturing the current K closest neighbours and their distances.
   Assumed not to be null, but may be empty or with less than K elements
   so far. It must be sorted from furthest away first to nearest last.</dd>
</dl>
</li>
</ul>
<a id="findKNearestNeighbours(int,double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findKNearestNeighbours</h4>
<pre class="methodSignature">public&nbsp;java.util.PriorityQueue&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;findKNearestNeighbours&#8203;(int&nbsp;K,
                                                                         double[][]&nbsp;sampleVectors)
                                                                  throws java.lang.Exception</pre>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd>
</dl>
</li>
</ul>
<a id="findKNearestNeighbours(int,double[][],infodynamics.utils.KdTree.KdTreeNode,int,java.util.PriorityQueue)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findKNearestNeighbours</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;findKNearestNeighbours&#8203;(int&nbsp;K,
                                      double[][]&nbsp;sampleVectors,
                                      <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                      int&nbsp;level,
                                      java.util.PriorityQueue&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;currentKBest)</pre>
<div class="block">Protected method to Update the k nearest neighbours to a given sample (samplePoint), from the tree
 rooted at node (which is at the specified level in the tree).
 Incorporate neighbours found in this sub-tree into the PriorityQueue
 of the current K closest.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>K</code> - the number of nearest neighbour</dd>
<dd><code>sampleVectors</code> - sample vectors (not necessarily in the tree) to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>currentKBest</code> - a PriorityQueue of NeighbourNodeData objects
   capturing the current K closest neighbours and their distances.
   Assumed not to be null, but may be empty or with less than K elements
   so far. It must be sorted from furthest away first to nearest last.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(int,double,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinR&#8203;(int&nbsp;sampleIndex,
                              double&nbsp;r,
                              boolean&nbsp;allowEqualToR)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">Count the number of points within norm r for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)">countPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within r.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;countPointsWithinR&#8203;(int&nbsp;sampleIndex,
                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                 int&nbsp;level,
                                 double&nbsp;r,
                                 boolean&nbsp;allowEqualToR)</pre>
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of points within r</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(int,double,int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinR&#8203;(int&nbsp;sampleIndex,
                              double&nbsp;r,
                              int&nbsp;dynCorrExclTime,
                              boolean&nbsp;allowEqualToR)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,int,boolean)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however any nodes within dynCorrExclTime are excluded from
 the search.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,int,boolean)">countPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within r.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;countPointsWithinR&#8203;(int&nbsp;sampleIndex,
                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                 int&nbsp;level,
                                 double&nbsp;r,
                                 int&nbsp;dynCorrExclTime,
                                 boolean&nbsp;allowEqualToR)</pre>
<div class="block">As per <a href="#countPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean)"><code>countPointsWithinR(int, KdTreeNode, int, double, boolean)</code></a>
 however excludes points within dynCorrExclTime of node
 from being counted.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. 0 means only exclude sampleIndex.</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of points within r</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(double[][],double,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinR&#8203;(double[][]&nbsp;sampleVectors,
                              double&nbsp;r,
                              boolean&nbsp;allowEqualToR)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#countPointsWithinR(double%5B%5D%5B%5D,double,boolean)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however the search is to match a specified sample point (not a sample
 point within the search space itself).</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#countPointsWithinR(double%5B%5D%5B%5D,double,boolean)">countPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleVectors</code> - sample vectors to find the neighbours within r
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within r.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(double[][],infodynamics.utils.KdTree.KdTreeNode,int,double,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;countPointsWithinR&#8203;(double[][]&nbsp;sampleVectors,
                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                 int&nbsp;level,
                                 double&nbsp;r,
                                 boolean&nbsp;allowEqualToR)</pre>
<div class="block">Count the number of points within radius r of a given sample (sampleVector),
 in the tree rooted at node (which is at the specified level in the tree).
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleVectors</code> - sample vectors to find the neighbours within r
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of points within r</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinR(int,double,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;java.util.Collection&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;findPointsWithinR&#8203;(int&nbsp;sampleIndex,
                                                                 double&nbsp;r,
                                                                 boolean&nbsp;allowEqualToR)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#findPointsWithinR(int,double,boolean)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however returns a collection rather than a count.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#findPointsWithinR(int,double,boolean)">findPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the collection of points within r.</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;findPointsWithinR&#8203;(int&nbsp;sampleIndex,
                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                 int&nbsp;level,
                                 double&nbsp;r,
                                 boolean&nbsp;allowEqualToR,
                                 java.util.Collection&lt;<a href="NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;pointsWithinR)</pre>
<div class="block">Add to the collection of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>pointsWithinR</code> - the collection of points to add to</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinR(int,double,boolean,boolean[],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;findPointsWithinR&#8203;(int&nbsp;sampleIndex,
                             double&nbsp;r,
                             boolean&nbsp;allowEqualToR,
                             boolean[]&nbsp;isWithinR,
                             int[]&nbsp;indicesWithinR)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#findPointsWithinR(int,double,boolean,boolean%5B%5D,int%5B%5D)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however records the nearest neighbours made within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points. indicesWithinR is 
 </p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#findPointsWithinR(int,double,boolean,boolean%5B%5D,int%5B%5D)">findPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>isWithinR</code> - the array MUST be passed in with all points set to
  false initially, and is returned indicating whether each sample was
  found to be within r of that at sampleIndex.</dd>
<dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the number of matching points found</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean[],int[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;findPointsWithinR&#8203;(int&nbsp;sampleIndex,
                                <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                int&nbsp;level,
                                double&nbsp;r,
                                boolean&nbsp;allowEqualToR,
                                boolean[]&nbsp;isWithinR,
                                int[]&nbsp;indicesWithinR,
                                int&nbsp;nextIndexInIndicesWithinR)</pre>
<div class="block">Record the collection of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).
 
 <p>The recording of nearest neighbours is made within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points. indicesWithinR is 
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>isWithinR</code> - the array should be passed in with all points set to
  false initially, and is return indicating whether each sample was
  found to be within r of that at sampleIndex.</dd>
<dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd>
<dd><code>nextIndexInIndicesWithinR</code> - the next available index in indicesWithinR
  before the method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the next available index in indicesWithinR after the method is complete</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinR(int,double,int,boolean,boolean[],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;findPointsWithinR&#8203;(int&nbsp;sampleIndex,
                              double&nbsp;r,
                              int&nbsp;dynCorrExclTime,
                              boolean&nbsp;allowEqualToR,
                              boolean[]&nbsp;isWithinR,
                              int[]&nbsp;indicesWithinR)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#findPointsWithinR(int,double,int,boolean,boolean%5B%5D,int%5B%5D)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">As per <a href="NearestNeighbourSearcher.html#findPointsWithinR(int,double,boolean,boolean%5B%5D,int%5B%5D)"><code>NearestNeighbourSearcher.findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 however incorporates dynamic correlation exclusion.
 </p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#findPointsWithinR(int,double,int,boolean,boolean%5B%5D,int%5B%5D)">findPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>isWithinR</code> - the array MUST be passed in with all points set to
  false initially, and is returned indicating whether each sample was
  found to be within r of that at sampleIndex.</dd>
<dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,int,boolean,boolean[],int[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;findPointsWithinR&#8203;(int&nbsp;sampleIndex,
                                <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                int&nbsp;level,
                                double&nbsp;r,
                                int&nbsp;dynCorrExclTime,
                                boolean&nbsp;allowEqualToR,
                                boolean[]&nbsp;isWithinR,
                                int[]&nbsp;indicesWithinR,
                                int&nbsp;nextIndexInIndicesWithinR)</pre>
<div class="block">As per <a href="#findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean%5B%5D,int%5B%5D,int)"><code>findPointsWithinR(int, KdTreeNode, int, double, boolean, boolean[], int[], int)</code></a>
  however with dynamic correlation time specified</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>isWithinR</code> - the array should be passed in with all points set to
  false initially, and is return indicating whether each sample was
  found to be within r of that at sampleIndex.</dd>
<dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd>
<dd><code>nextIndexInIndicesWithinR</code> - the next available index in indicesWithinR
  before the method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the next available index in indicesWithinR after the method is complete</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinR(int,double,int,boolean,boolean[],double[],double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;findPointsWithinR&#8203;(int&nbsp;sampleIndex,
                             double&nbsp;r,
                             int&nbsp;dynCorrExclTime,
                             boolean&nbsp;allowEqualToR,
                             boolean[]&nbsp;isWithinR,
                             double[]&nbsp;distancesWithinRInOrder,
                             double[][]&nbsp;distancesAndIndicesWithinR)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#findPointsWithinR(int,double,int,boolean,boolean%5B%5D,double%5B%5D,double%5B%5D%5B%5D)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">As per <a href="NearestNeighbourSearcher.html#findPointsWithinR(int,double,boolean,boolean%5B%5D,int%5B%5D)"><code>NearestNeighbourSearcher.findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 however incorporates dynamic correlation exclusion.
 </p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#findPointsWithinR(int,double,int,boolean,boolean%5B%5D,double%5B%5D,double%5B%5D%5B%5D)">findPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>isWithinR</code> - the array MUST be passed in with all points set to
  false initially, and is returned indicating whether each sample was
  found to be within r of that at sampleIndex.</dd>
<dd><code>distancesWithinRInOrder</code> - the array must be passed in and is
  returned with distances for each point found to be within r. Values
  at other indices are not defined.</dd>
<dd><code>distancesAndIndicesWithinR</code> - is returned as 
  a list of distances (in column index 0) 
  and array indices (in column index 1)
  for points marked as true in isWithinR, terminated with a -1 value on the index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the point count</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,int,boolean,boolean[],double[],double[][],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;findPointsWithinR&#8203;(int&nbsp;sampleIndex,
                                <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                int&nbsp;level,
                                double&nbsp;r,
                                int&nbsp;dynCorrExclTime,
                                boolean&nbsp;allowEqualToR,
                                boolean[]&nbsp;isWithinR,
                                double[]&nbsp;distancesWithinRInOrder,
                                double[][]&nbsp;distancesAndIndicesWithinR,
                                int&nbsp;nextIndexInIndicesWithinR)</pre>
<div class="block">As per <a href="#findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean%5B%5D,int%5B%5D,int)"><code>findPointsWithinR(int, KdTreeNode, int, double, boolean, boolean[], int[], int)</code></a>
  however with dynamic correlation time specified, and 
  returning distances to neighbours as well as neighbour indices.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>isWithinR</code> - the array should be passed in with all points set to
  false initially, and is return indicating whether each sample was
  found to be within r of that at sampleIndex.</dd>
<dd><code>distancesWithinRInOrder</code> - the array must be passed in and is
  returned with distances for each point found to be within r. Values
  at other indices are not defined.</dd>
<dd><code>distancesAndIndicesWithinR</code> - a list of distances (in column index 0) 
  and array indices (in column index 1)
  for points marked as true in isWithinR, terminated with a -1 value on the index.</dd>
<dd><code>nextIndexInIndicesWithinR</code> - the next available index in indicesWithinR
  before the method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the next available index in distancesAndIndicesWithinR after the method is complete</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinRAndTakeRadiusMax(int,double,int,boolean,int,boolean[],double[],double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinRAndTakeRadiusMax</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;findPointsWithinRAndTakeRadiusMax&#8203;(int&nbsp;sampleIndex,
                                             double&nbsp;r,
                                             int&nbsp;dynCorrExclTime,
                                             boolean&nbsp;allowEqualToR,
                                             int&nbsp;variableAlreadyTested,
                                             boolean[]&nbsp;testResultsForGivenVariable,
                                             double[]&nbsp;distancesWithinRForGivenVariable,
                                             double[][]&nbsp;distancesAndIndicesWithinR)</pre>
<div class="block">As per <a href="#findPointsWithinR(int,double,int,boolean,boolean%5B%5D,double%5B%5D,double%5B%5D%5B%5D)"><code>findPointsWithinR(int, double, int, boolean, boolean[], double[], double[][])</code></a>
 only we have a sub-variable already tested, and we incorporate its results here.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>variableAlreadyTested</code> - </dd>
<dd><code>testResultsForGivenVariable</code> - an array indicating whether each sample for
  variableAlreadyTested was within radius for this search point</dd>
<dd><code>distancesWithinRForGivenVariable</code> - an array of distances for
  variableAlreadyTested for each sample
  found to be within r. Values at other indices are not defined.</dd>
<dd><code>distancesAndIndicesWithinR</code> - a list of distances (in column index 0) 
  and array indices (in column index 1)
  for points found to be within r, terminated with a -1 value on the index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the next available index in distancesAndIndicesWithinR after the method is complete</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinRAndTakeRadiusMax(int,infodynamics.utils.KdTree.KdTreeNode,int,double,int,boolean,int,boolean[],double[],double[][],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinRAndTakeRadiusMax</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;findPointsWithinRAndTakeRadiusMax&#8203;(int&nbsp;sampleIndex,
                                                <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                                int&nbsp;level,
                                                double&nbsp;r,
                                                int&nbsp;dynCorrExclTime,
                                                boolean&nbsp;allowEqualToR,
                                                int&nbsp;variableAlreadyTested,
                                                boolean[]&nbsp;testResultsForGivenVariable,
                                                double[]&nbsp;distancesWithinRForGivenVariable,
                                                double[][]&nbsp;distancesAndIndicesWithinR,
                                                int&nbsp;nextIndexInIndicesWithinR)</pre>
<div class="block">As per <a href="#findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,int,boolean,boolean%5B%5D,double%5B%5D,double%5B%5D%5B%5D,int)"><code>findPointsWithinR(int, KdTreeNode, int, double, int, boolean, boolean[], double[], double[][], int)</code></a>
 only we have a sub-variable already tested, and we incorporate its results here.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>variableAlreadyTested</code> - </dd>
<dd><code>testResultsForGivenVariable</code> - an array indicating whether each sample for
  variableAlreadyTested was within radius for this search point</dd>
<dd><code>distancesWithinRForGivenVariable</code> - an array of distances for
  variableAlreadyTested for each sample
  found to be within r. Values at other indices are not defined.</dd>
<dd><code>distancesAndIndicesWithinR</code> - a list of distances (in column index 0) 
  and array indices (in column index 1)
  for points found to be within r, terminated with a -1 value on the index.</dd>
<dd><code>nextIndexInIndicesWithinR</code> - the next available index in indicesWithinR
  before the method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the next available index in distancesAndIndicesWithinR after the method is complete</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinR(double,double[][],boolean,boolean[],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;findPointsWithinR&#8203;(double&nbsp;r,
                              double[][]&nbsp;samplePoint,
                              boolean&nbsp;allowEqualToR,
                              boolean[]&nbsp;isWithinR,
                              int[]&nbsp;indicesWithinR)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#findPointsWithinR(double,double%5B%5D%5B%5D,boolean,boolean%5B%5D,int%5B%5D)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however records the nearest neighbours for a sample data point
  (which may not be in the search tree), within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points. indicesWithinR is 
 </p></div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#findPointsWithinR(double,double%5B%5D%5B%5D,boolean,boolean%5B%5D,int%5B%5D)">findPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>samplePoint</code> - sample vectors to find the neighbours within r
  for</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>isWithinR</code> - the array MUST be passed in with all points set to
  false initially, and is returned indicating whether each sample was
  found to be within r of that at sampleIndex.</dd>
<dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinR(double[][],infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean[],int[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;findPointsWithinR&#8203;(double[][]&nbsp;sampleVectors,
                                <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                int&nbsp;level,
                                double&nbsp;r,
                                boolean&nbsp;allowEqualToR,
                                boolean[]&nbsp;isWithinR,
                                int[]&nbsp;indicesWithinR,
                                int&nbsp;nextIndexInIndicesWithinR)</pre>
<div class="block">Record the collection of points within radius r of a given sample (sampleVectors),
 in the tree rooted at node (which is at the specified level in the tree).
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).
 
 <p>The recording of nearest neighbours is made within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points. indicesWithinR is 
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleVectors</code> - sample vectors to find the neighbours within r
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>isWithinR</code> - the array should be passed in with all points set to
  false initially, and is return indicating whether each sample was
  found to be within r of that at sampleIndex.</dd>
<dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd>
<dd><code>nextIndexInIndicesWithinR</code> - the next available index in indicesWithinR
  before the method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the next available index in indicesWithinR after the method is complete</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(int,double,boolean,int,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinR&#8203;(int&nbsp;sampleIndex,
                              double&nbsp;r,
                              boolean&nbsp;allowEqualToR,
                              int&nbsp;variableAlreadyTested,
                              boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="#countPointsWithinR(int,double,boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 with an additional factor as follows.
 
 <p>For this method, one of the high-level variables has already had their
 norms tested against r; this variable is indicated by variableAlreadyTested
 and the results are contained in the testResultsForGivenVariable array.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd>
<dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within r for each
   sample index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within r.</dd>
</dl>
</li>
</ul>
<a id="countPointsStrictlyWithinR(int,double,int,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsStrictlyWithinR</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsStrictlyWithinR&#8203;(int&nbsp;sampleIndex,
                                      double&nbsp;r,
                                      int&nbsp;variableAlreadyTested,
                                      boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="#countPointsWithinR(int,double,boolean,int,boolean%5B%5D)"><code>countPointsWithinR(int, double, boolean, int, boolean[])</code></a>
 with allowEqualToR == false</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd>
<dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within r for each
   sample index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within r.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinOrOnR(int,double,int,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinOrOnR</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinOrOnR&#8203;(int&nbsp;sampleIndex,
                                  double&nbsp;r,
                                  int&nbsp;variableAlreadyTested,
                                  boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="#countPointsWithinR(int,double,boolean,int,boolean%5B%5D)"><code>countPointsWithinR(int, double, boolean, int, boolean[])</code></a>
 with allowEqualToR == true</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd>
<dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within r for each
   sample index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within r.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,int,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;countPointsWithinR&#8203;(int&nbsp;sampleIndex,
                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                 int&nbsp;level,
                                 double&nbsp;r,
                                 boolean&nbsp;allowEqualToR,
                                 int&nbsp;variableAlreadyTested,
                                 boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 when one of the variables has already been tested.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd>
<dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within r for each
   sample index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of points within r</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(double,double[][],boolean,int,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinR&#8203;(double&nbsp;r,
                              double[][]&nbsp;sampleVectors,
                              boolean&nbsp;allowEqualToR,
                              int&nbsp;variableAlreadyTested,
                              boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="#countPointsWithinR(int,double,boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>, except searches for a specified
 sample point rather than a point associated with an index in the existing sample set, and
 with an additional factor as follows.
 
 <p>For this method, one of the high-level variables has already had their
 norms tested against r; this variable is indicated by variableAlreadyTested
 and the results are contained in the testResultsForGivenVariable array.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>sampleVectors</code> - sample vectors (not necessarily in the tree) to find a nearest neighbour
  for</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd>
<dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within r for each
   sample index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within r.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(double[][],infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,int,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;countPointsWithinR&#8203;(double[][]&nbsp;sampleVectors,
                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                 int&nbsp;level,
                                 double&nbsp;r,
                                 boolean&nbsp;allowEqualToR,
                                 int&nbsp;variableAlreadyTested,
                                 boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">Count the number of points within radius r of a given sample (sampleVectors),
 in the tree rooted at node (which is at the specified level in the tree),
 when one of the variables has already been tested.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleVectors</code> - sample vectors (not necessarily in the tree) to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd>
<dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within r for each
   sample index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of points within r</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinRs(int,double[],int,boolean,boolean[],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinRs</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;findPointsWithinRs&#8203;(int&nbsp;sampleIndex,
                              double[]&nbsp;rs,
                              int&nbsp;dynCorrExclTime,
                              boolean&nbsp;allowEqualToR,
                              boolean[]&nbsp;isWithinR,
                              int[]&nbsp;indicesWithinR)</pre>
<div class="block">As per <a href="#findPointsWithinR(int,double,int,boolean,boolean%5B%5D,int%5B%5D)"><code>findPointsWithinR(int, double, int, boolean, boolean[], int[])</code></a>
  however using multiple radii for each variable.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour for</dd>
<dd><code>rs</code> - radii within which to count points (one for each variable)</dd>
<dd><code>dynCorrExclTime</code> - time window within which to exclude points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also, otherwise only those strictly within r</dd>
<dd><code>isWithinR</code> - the array MUST be passed in with all points set to false initially, and is returned indicating whether each sample was found to be within r of that at sampleIndex.</dd>
<dd><code>indicesWithinR</code> - a list of array indices for points marked as true in isWithinR, terminated with a -1 value.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the number of points found to match</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinRs(int,infodynamics.utils.KdTree.KdTreeNode,int,double[],int,boolean,boolean[],int[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinRs</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;findPointsWithinRs&#8203;(int&nbsp;sampleIndex,
                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                 int&nbsp;level,
                                 double[]&nbsp;rs,
                                 int&nbsp;dynCorrExclTime,
                                 boolean&nbsp;allowEqualToR,
                                 boolean[]&nbsp;isWithinR,
                                 int[]&nbsp;indicesWithinR,
                                 int&nbsp;nextIndexInIndicesWithinR)</pre>
<div class="block">As per <a href="#findPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,int,boolean,boolean%5B%5D,int%5B%5D,int)"><code>findPointsWithinR(int, KdTreeNode, int, double, int, boolean, boolean[], int[], int)</code></a>
  however with dynamic correlation time specified</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>rs</code> - radii within which to count points (one for each variable)</dd>
<dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>isWithinR</code> - the array should be passed in with all points set to
  false initially, and is return indicating whether each sample was
  found to be within r of that at sampleIndex.</dd>
<dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd>
<dd><code>nextIndexInIndicesWithinR</code> - the next available index in indicesWithinR
  before the method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the next available index in indicesWithinR after the method is complete</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinRs(double[],double[][],boolean,boolean[],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinRs</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;findPointsWithinRs&#8203;(double[]&nbsp;rs,
                               double[][]&nbsp;samplePoint,
                               boolean&nbsp;allowEqualToR,
                               boolean[]&nbsp;isWithinR,
                               int[]&nbsp;indicesWithinR)</pre>
<div class="block">As per {@link #findPointsWithinR(double[], double[][], boolean, boolean[], int[]))}
  however using multiple radii for each variable.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rs</code> - radii within which to count points (one for each variable)</dd>
<dd><code>samplePoint</code> - sample vectors to find the neighbours within rs for</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also, otherwise only those strictly within r</dd>
<dd><code>isWithinR</code> - the array MUST be passed in with all points set to false initially, and is returned indicating whether each sample was found to be within r of that at sampleIndex.</dd>
<dd><code>indicesWithinR</code> - a list of array indices for points marked as true in isWithinR, terminated with a -1 value.</dd>
</dl>
</li>
</ul>
<a id="findPointsWithinRs(double[][],infodynamics.utils.KdTree.KdTreeNode,int,double[],boolean,boolean[],int[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinRs</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;findPointsWithinRs&#8203;(double[][]&nbsp;sampleVectors,
                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                 int&nbsp;level,
                                 double[]&nbsp;rs,
                                 boolean&nbsp;allowEqualToR,
                                 boolean[]&nbsp;isWithinR,
                                 int[]&nbsp;indicesWithinR,
                                 int&nbsp;nextIndexInIndicesWithinR)</pre>
<div class="block">Record the collection of points within radii rs of a given sample (sampleVectors),
 in the tree rooted at node (which is at the specified level in the tree).
 Nearest neighbour function to compare to rs is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).
 
 <p>The recording of nearest neighbours is made within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points. indicesWithinR is 
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleVectors</code> - sample vectors to find the neighbours within r
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>rs</code> - radii within which to count points (one for each variable)</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>isWithinR</code> - the array should be passed in with all points set to
  false initially, and is return indicating whether each sample was
  found to be within r of that at sampleIndex.</dd>
<dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd>
<dd><code>nextIndexInIndicesWithinR</code> - the next available index in indicesWithinR
  before the method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the next available index in indicesWithinR after the method is complete</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinRs(int,double[],boolean,int,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinRs</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinRs&#8203;(int&nbsp;sampleIndex,
                               double[]&nbsp;rs,
                               boolean&nbsp;allowEqualToR,
                               int&nbsp;variableAlreadyTested,
                               boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="#countPointsWithinRs(int,double%5B%5D,boolean)"><code>countPointsWithinRs(int, double[], boolean)</code></a>
 with an additional factor as follows.
 
 <p>For this method, one of the high-level variables has already had their
 norms tested against the relevant r; this variable is indicated by variableAlreadyTested
 and the results are contained in the testResultsForGivenVariable array.
 </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>rs</code> - radii for each variable within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radii rs also,
   otherwise only those strictly within rs</dd>
<dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd>
<dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within rs[variableAlreadyTested]
   for each sample index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within rs.</dd>
</dl>
</li>
</ul>
<a id="countPointsStrictlyWithinRs(int,double[],int,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsStrictlyWithinRs</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsStrictlyWithinRs&#8203;(int&nbsp;sampleIndex,
                                       double[]&nbsp;rs,
                                       int&nbsp;variableAlreadyTested,
                                       boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="#countPointsWithinRs(int,double%5B%5D,boolean,int,boolean%5B%5D)"><code>countPointsWithinRs(int, double[], boolean, int, boolean[])</code></a>
 with allowEqualToR == false</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>rs</code> - radii for each variable within which to count points</dd>
<dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd>
<dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within rs[variableAlreadyTested]
   for each sample index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within rs.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinOrOnRs(int,double[],int,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinOrOnRs</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinOrOnRs&#8203;(int&nbsp;sampleIndex,
                                   double[]&nbsp;rs,
                                   int&nbsp;variableAlreadyTested,
                                   boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="#countPointsWithinRs(int,double%5B%5D,boolean,int,boolean%5B%5D)"><code>countPointsWithinRs(int, double[], boolean, int, boolean[])</code></a>
 with allowEqualToR == true</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>rs</code> - radii for each variable within which to count points</dd>
<dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd>
<dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within rs[variableAlreadyTested]
   for each sample index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within rs.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinRs(int,infodynamics.utils.KdTree.KdTreeNode,int,double[],boolean,int,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinRs</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;countPointsWithinRs&#8203;(int&nbsp;sampleIndex,
                                  <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                  int&nbsp;level,
                                  double[]&nbsp;rs,
                                  boolean&nbsp;allowEqualToR,
                                  int&nbsp;variableAlreadyTested,
                                  boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">Count the number of points within norms {r1,r2,etc} for each high-level
  variable, for a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 when one of the variables has already been tested.
 The node itself is excluded from the search.
 Nearest neighbour function to compare to {r1,r2,etc}
  for each variable is the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>rs</code> - radii for each variable within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd>
<dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within rs[variableAlreadyTested]
   for each sample index.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of points within rs</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(int,double,boolean,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinR&#8203;(int&nbsp;sampleIndex,
                              double&nbsp;r,
                              boolean&nbsp;allowEqualToR,
                              boolean[]&nbsp;additionalCriteria)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean,boolean%5B%5D)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean,boolean%5B%5D)">countPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>additionalCriteria</code> - array of booleans. Only count a point if it
  is within r and is true in additionalCrtieria.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within r.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;countPointsWithinR&#8203;(int&nbsp;sampleIndex,
                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                 int&nbsp;level,
                                 double&nbsp;r,
                                 boolean&nbsp;allowEqualToR,
                                 boolean[]&nbsp;additionalCriteria)</pre>
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 subject to an additional criteria.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>additionalCriteria</code> - array of booleans. Only count a point if it
  is within r and is true in additionalCrtieria.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of points within r</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(int,double,boolean,boolean[],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinR&#8203;(int&nbsp;sampleIndex,
                              double&nbsp;r,
                              boolean&nbsp;allowEqualToR,
                              boolean[]&nbsp;additionalCriteria,
                              int[]&nbsp;remapping)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean,boolean%5B%5D,int%5B%5D)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria, 
 and the search points are reindexed according to the remapping
 specified in remapping</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#countPointsWithinR(int,double,boolean,boolean%5B%5D,int%5B%5D)">countPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for (already remapped if required)</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>additionalCriteria</code> - array of booleans. Only count a point if it
  is within r and is true in additionalCrtieria.</dd>
<dd><code>remapping</code> - array of time indices with which to remap the search points
  onto the same time index space as the additionalCriteria (this will
  apply to the supplied sampleIndex as well as other search points)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within r.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(int,infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean[],int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;countPointsWithinR&#8203;(int&nbsp;sampleIndex,
                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                 int&nbsp;level,
                                 double&nbsp;r,
                                 boolean&nbsp;allowEqualToR,
                                 boolean[]&nbsp;additionalCriteria,
                                 int[]&nbsp;remapping)</pre>
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 subject to an additional criteria,
 and the search points are reindexed according to the remapping specified in remapping.
 
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>additionalCriteria</code> - array of booleans. Only count a point if it
  is within r and is true in additionalCrtieria.</dd>
<dd><code>remapping</code> - array of time indices with which to remap the search points
  onto the same time index space as the additionalCriteria (this will
  apply to the supplied sampleIndex as well as other search points)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of points within r</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(double[][],double,boolean,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinR&#8203;(double[][]&nbsp;sampleVectors,
                              double&nbsp;r,
                              boolean&nbsp;allowEqualToR,
                              boolean[]&nbsp;additionalCriteria)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from class:&nbsp;<code><a href="NearestNeighbourSearcher.html#countPointsWithinR(double%5B%5D%5B%5D,double,boolean,boolean%5B%5D)">NearestNeighbourSearcher</a></code></span></div>
<div class="block">As per <a href="NearestNeighbourSearcher.html#countPointsWithinR(double%5B%5D%5B%5D,double,boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(double[][], double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="NearestNeighbourSearcher.html#countPointsWithinR(double%5B%5D%5B%5D,double,boolean,boolean%5B%5D)">countPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleVectors</code> - sample vectors to find the neighbours within r
  for</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>additionalCriteria</code> - array of booleans. Only count a point if it
  is within r and is true in additionalCrtieria.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within r.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinR(double[][],infodynamics.utils.KdTree.KdTreeNode,int,double,boolean,boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;countPointsWithinR&#8203;(double[][]&nbsp;sampleVectors,
                                 <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                 int&nbsp;level,
                                 double&nbsp;r,
                                 boolean&nbsp;allowEqualToR,
                                 boolean[]&nbsp;additionalCriteria)</pre>
<div class="block">Count the number of points within radius r of a given sample (sampleVectors -- from outside the tree),
 in the tree rooted at node (which is at the specified level in the tree),
 subject to an additional criteria.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleVectors</code> - sample vectors to find the neighbours within r
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>r</code> - radius within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dd><code>additionalCriteria</code> - array of booleans. Only count a point if it
  is within r and is true in additionalCrtieria.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of points within r</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinRs(int,double[],boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinRs</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinRs&#8203;(int&nbsp;sampleIndex,
                               double[]&nbsp;rs,
                               boolean&nbsp;allowEqualToR)</pre>
<div class="block">Count the number of points within norms {r1,r2,etc} for each high-level
  variable, for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to {r1,r2,etc}
  for each variable is the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>rs</code> - radii for each variable within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radii rs also,
   otherwise only those strictly within rs</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within rs.</dd>
</dl>
</li>
</ul>
<a id="countPointsStrictlyWithinRs(int,double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsStrictlyWithinRs</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsStrictlyWithinRs&#8203;(int&nbsp;sampleIndex,
                                       double[]&nbsp;rs)</pre>
<div class="block">Count the number of points strictly within norms {r1,r2,etc} for each high-level
  variable, for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to {r1,r2,etc}
  for each variable is the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>rs</code> - radii for each variable within which to count points</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within r.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinOrOnRs(int,double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinOrOnRs</h4>
<pre class="methodSignature">public&nbsp;int&nbsp;countPointsWithinOrOnRs&#8203;(int&nbsp;sampleIndex,
                                   double[]&nbsp;rs)</pre>
<div class="block">Count the number of points within or at norms {r1,r2,etc} for each high-level
  variable, for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to {r1,r2,etc}
  for each variable is the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>rs</code> - radii for each variable within which to count points</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the count of points within or on r.</dd>
</dl>
</li>
</ul>
<a id="countPointsWithinRs(int,infodynamics.utils.KdTree.KdTreeNode,int,double[],boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinRs</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;countPointsWithinRs&#8203;(int&nbsp;sampleIndex,
                                  <a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                  int&nbsp;level,
                                  double[]&nbsp;rs,
                                  boolean&nbsp;allowEqualToR)</pre>
<div class="block">Count the number of points within norms {r1,r2,etc} for each high-level
  variable, for a given
  sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).
 The node itself is excluded from the search.
 Nearest neighbour function to compare to {r1,r2,etc}
  for each variable is the specified norm.
 (If <a href="EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd>
<dd><code>level</code> - which level we're currently at in the tree</dd>
<dd><code>rs</code> - radii for each variable within which to count points</dd>
<dd><code>allowEqualToR</code> - if true, then count points at radii rs also,
   otherwise only those strictly within r</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>count of points within r</dd>
</dl>
</li>
</ul>
<a id="print()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>print</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;print()</pre>
<div class="block">Internal utility function for debug printing of a tree</div>
</li>
</ul>
<a id="print(infodynamics.utils.KdTree.KdTreeNode,int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>print</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;print&#8203;(<a href="KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                     int&nbsp;level)</pre>
<div class="block">Internal utility function for debug printing of a node and
  all of its descendants</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - current node</dd>
<dd><code>level</code> - which level we're at in the tree</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
